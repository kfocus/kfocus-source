#!/bin/bash
#
# Copyright 2022-2024 MindShare Inc.
#
# Written for the Kubuntu Focus by A. Rainbolt and M. Mikowski
#
# Name     : kfocus-rollback-set
# Summary  : kfocus-rollback-set (createSnapshot
#              <Apt|Timed|Pre-Rollback|(username)>
#              | restoreSnapshot @<timestamp> | deleteSnapshot @<timestamp>
#              | labelAptSnapshot | finalizeRestore  | trimSnapshots
#              | prepareSystem    | getBtrfsStatus
#              | restoreSnapshot (snapshot_id)       | systemSnapshot
# Purpose  : Performs snapshot management operations
# Example  : kfocus-rollback-set restoreSnapshot @1234
# License  : GPLv2
# Run By   : kfocus-rollback, kfocus-snapshot, system processes
# Spec     : 4013
# Note     : WORK IN PROGRESS, DO NOT USE IN PRODUCTION
#
set -u;

_stderrFn () {
  2>&1 echo "${_baseName} $*";
}
## BEGIN _loadLibTableFn {
# Summary : _loadLibTableFn <lib_str1> <lib_str2> ...
# Example : _loadLibTableFn "lib01:/usr/lib/lib01" "lib02";
# Purpose :
#   Import table of libs, one arg per lib.
#     * Each arg can have alternates delimited by colons ':'
#     * Fails if all alternates for a lib fails.
#     * Starting lib string '#:' means the following libs are optional.
#     * Diagnostics are sent to STDERR.
#     * Libs without a directory use ${_binDir} as the path
#
_loadLibTableFn () {
  declare _lib_table _lib_list _lib_line _raw_path _lib_file _is_loaded;
  _lib_table=("$@");

  ## Begin: Iterate over lib lines.
  for _lib_line in "${_lib_table[@]}"; do
    # Split line into alternates.
    #   Note: Echo removes trailing newline.
    readarray -d: -t _lib_list < <(echo -n "${_lib_line}");
    _is_loaded='n';

    ## Begin: Iterate over alternates.
    for _raw_path in "${_lib_list[@]}"; do
      [ -z "$(dirname "${_raw_path}")" ] \
        && _lib_file="${_binDir}/${_raw_path}" \
        || _lib_file="${_raw_path}";

      # shellcheck disable=SC1090
      if ! [ -r "${_lib_file}" ]; then
        _stderrFn "warn: source |${_lib_file}| not readable.";
      elif source "${_lib_file}"; then
        _is_loaded='y';
        break;
      else
        _stderrFn "${_baseName} Error: source |${_lib_file}| is non-zero.";
        return 1;
      fi  
    done
    ## . End: Iterate over alternates.

    if [ "${_is_loaded}" != 'y' ]; then
      _stderrFn "${_baseName} error: no lib loaded";
      return 1;
    fi  
  done
  ## . End: Iterate over lib lines.

  return;
}
## . END _loadLibTableFn }

## BEGIN Define error and exit handling {
_trapExitFn () {
  1>&2 echo "${_baseName} was interrupted";
  if [ "${_isPreparingSystem}" = 'y' ]; then
    _promptAllUsersFn 'error' "${_prepareFailMsg}";
  fi
  rm "${_lockFile}" || true;
}

_chkSetFlockFn () {
  exec 211>"${_lockFile}" || exit 21;
  if ! flock -n -e 211; then
    1>&2 echo "Cannot get lock on ${_lockFile}";
    exit 20;
  fi
  # Trap unexpected exits to clean up lock file
  trap _trapExitFn EXIT;
}

_exitCleanFn () {
  declare _int;
  _int="$(_cm2EchoIntFn "${1:-0}")";
  trap '' EXIT;
  rm "${_lockFile}" || true;
  exit "${_int}";
}

_exitWithCodeFn () {
  declare _int _msg;

  _int="$(_cm2EchoIntFn "${1:-0}")";
  _msg="${2:-}";

  if [ -n "${_msg}" ]; then
    1>&2 echo "${_msg}";
  fi
  _exitCleanFn "${_int}";
}

_exitNOTICE () { _exitWithCodeFn  0 "$@"; }
_exitERR ()    { _exitWithCodeFn  1 "$@"; }
_exitCRIT ()   { _exitWithCodeFn  2 "$@"; }
_exitALERT ()  { _exitWithCodeFn  3 "$@"; }
_exitEMERG ()  { _exitWithCodeFn  4 "$@"; }
## . END Define error and exit handling }

## BEGIN _promptAllUsersFn {
# See https://stackoverflow.com/a/49533938
_promptAllUsersFn () {
  declare _mode _msg _xserver_id _user_name;
  _mode="${1:-info}";
  _msg="${2:-blank}";

  while read -r _xserver_id; do
    _user_name="$(
      who | grep "(:${_xserver_id})" | head -n1 | awk '{ print $1 }'
    )";
    if [ -z "${_user_name}" ]; then continue; fi

    sudo -u "${_user_name}" \
      DISPLAY="${_xserver_id}" \
      DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$(id -u "${_user_name}")/bus" \
      qdbus org.kfocus.FocusRxDispatch.launcher / "${_mode}" "${_msg}";
  done < <(_cm2LsFn '/tmp/.X11-unix/' | sed 's?/tmp/.X11-unix/X??')
}
## . END _promptAllUsersFn }

## BEGIN _checkBtrfsStatusFn {
_checkBtrfsStatusFn () {
  declare _main_fs _boot_fs _main_subvols_str _boot_subvols_str;

  # The presence of /var/lib/portables or /var/lib/machines subvolumes will
  # interfere with snapshotting. These subvolumes may be created automatically
  # by systemd if it is not configured otherwise.
  if grep -q 'var/lib/portables' < <(btrfs subvolume list /) || \
     grep -q 'var/lib/machines' < <(btrfs subvolume list /); then
    if [ -n "$(ls -A /var/lib/portables)" ] || \
       [ -n "$(ls -A /var/lib/machines )" ]; then
      _btrfsStatus='UNSUPPORTED';
    fi
  fi

  if [ -d '/btrfs_main' ] && [ -d '/btrfs_boot' ]; then
    if [ -d '/btrfs_main/@' ] \
      && [ -d "${_snapshotMainDir}" ] \
      && [ -d '/btrfs_boot/@boot' ] \
      && [ -d "${_snapshotBootDir}" ]; then
      _btrfsStatus='SUPPORTED, SET UP';
    else
      _btrfsStatus='UNSUPPORTED';
    fi
  else
    if ! [ -d '/btrfs_main' ] && ! [ -d '/btrfs_boot' ]; then
      _main_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on / ' \
        | cut -d' ' -f1)";
      _boot_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on /boot ' \
        | cut -d' ' -f1)";
      if [ -n "${_main_fs}" ] && [ -n "${_boot_fs}" ] \
        && [ "${_main_fs}" != "${_boot_fs}" ]; then
        _main_subvols_str="$(btrfs subvolume list / | awk '{ print $9 }' | sort)";
        _boot_subvols_str="$(btrfs subvolume list /boot | awk '{ print $9 }' | sort)";
        if grep -E '^@$' <<< "${_main_subvols_str}" && \
          LC_ALL='C' mount | grep -q ' on /home '; then
          if [ -z "${_boot_subvols_str}" ]; then
            _btrfsStatus='SUPPORTED, NOT SET UP';
          else
            _btrfsStatus='UNSUPPORTED';
          fi
        else
          _btrfsStatus='UNSUPPORTED';
        fi
      else
        _btrfsStatus='UNSUPPORTED';
      fi
    else
      _btrfsStatus='INCONSISTENT';
    fi
  fi
}
## . END _checkBtrfsStatusFn }

_checkBtrfsStatusSetUpFn () {
  if ! [ "${_btrfsStatus}" = 'SUPPORTED, SET UP' ]; then
    _exitNOTICE "${_btrfsStatus}";
  fi
}

_getSnapshotListStrFn () {
  # TODO 2024-04-05 mmikowski warm: use _cm2LsFn instead here
  find "${_snapshotMainDir}" -maxdepth 1 \
    | cut -d'@' -f3 \
    | sort -n -r \
    | sed '/^$/d; s/^/@/;';
}

_prepareSystemFn () {
  declare _root_mount_id _boot_mount_id _btrfs_defaults_str \
    _dir _subvolume_list _subvolume_id;

  _isPreparingSystem='y';

  ## Begin STAGE 1: Check and prep filesystem {
  if [ "${_btrfsStatus}" = 'SUPPORTED, SET UP' ]; then
    _exitNOTICE 'This system already appears snapshot-enabled.';
  fi

  if [ "${_btrfsStatus}" = 'UNSUPPORTED' ]; then
    _exitERR 'This system does not support snapshotting.';
  fi

  # Check libvirt dirs, if they have content do not proceed
  if [ -d '/etc/libvirt' ] || [ -d '/var/lib/libvirt' ]; then
    if [ -n "$(ls -A /etc/libvirt     2>/dev/null)" ] || \
       [ -n "$(ls -A /var/lib/libvirt 2>/dev/null)" ]; then
      _exitERR 'Cannot create libvirt subvols, libvirt is installed!';
    fi
  fi

  # systemd may create /var/lib/portables and /var/lib/machines BTRFS
  # subvolumes of its own accord if not configured otherwise. Ensure that
  # these are not present.
  btrfs subvolume delete --commit-after '/var/lib/portables' || true;
  btrfs subvolume delete --commit-after '/var/lib/machines'  || true;

  # Create directories
  for _dir in '/btrfs_boot' '/btrfs_main' '/etc/libvirt' '/var/lib/libvirt'; do
    mkdir -p "${_dir}" || _exitCRIT "Cannot create ${_dir}";
  done;
  ## . End STAGE 1: Check and prep filesystem }

  ## Begin STAGE 2: Adjust fstab {
  _root_mount_id="$(LC_ALL=C mount | grep ' on / ' | cut -d' ' -f1)";
  _root_mount_id="UUID=$(LC_ALL=C lsblk -o NAME,FSTYPE,UUID,MOUNTPOINTS \
    "${_root_mount_id}" | sed -n '2p' | awk '{ print $3 }')";
  _boot_mount_id="UUID=$(LC_ALL=C lsblk -o NAME,FSTYPE,UUID,MOUNTPOINTS \
    | grep -P '/boot$' | awk '{ print $3 }')";
  _btrfs_defaults_str="defaults,noatime,autodefrag 0 0";

  echo "${_root_mount_id} /btrfs_main btrfs subvolid=5,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /btrfs_main';
  echo "${_boot_mount_id} /btrfs_boot btrfs subvolid=5,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /btrfs_boot';
  echo "${_root_mount_id} /etc/libvirt btrfs subvol=@libvirt-machines/@etc-libvirt,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /etc/libvirt';
  echo "${_root_mount_id} /var/lib/libvirt btrfs subvol=@libvirt-machines/@var-lib-libvirt,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /var/lib/libvirt';
  ## . End STAGE 2: Adjust fstab }

  ## Begin STAGE 3: Prepare /boot {
  # Unmount boot-related directories, so we can rearrange their contents
  umount /boot/efi || _exitALERT 'Failed to unmount /boot/efi';
  umount /boot     || _exitALERT 'Failed to unmount /boot';

  # Point fstab at a soon-to-be-created @boot subvolume.
  sed -i '/\/boot /s/defaults/subvol=\/@boot,defaults/' /etc/fstab \
    || _exitALERT 'Failed to update fstab for @boot';

  # Reload fstab changes
  systemctl daemon-reload;

  # Morph the layout of the boot partition
  mount /btrfs_boot || _exitALERT 'Failed to mount /btrfs_boot';
  btrfs subvolume create /btrfs_boot/@boot \
    || _exitEMERG 'Failed to create @boot';

  # This will always throw a warning about not being able to move a directory
  # into itself, therefore we have to ignore it
  mv /btrfs_boot/* /btrfs_boot/@boot/ 2>/dev/null || true;

  # Mount /boot again after successful rearrange
  mount /boot     || _exitALERT 'Failed to mount /boot';
  mount /boot/efi || _exitALERT 'Failed to mount /boot/efi';

  # Point the primary grub.cfg at the new boot files
  update-grub || _exitALERT 'Failed to update GRUB configuration';

  # Make sure GRUB can find the primary grub.cfg at its new location
  sed -i "s/'\/grub'/'\/@boot\/grub'/" /boot/efi/EFI/ubuntu/grub.cfg \
    || _exitALERT 'Failed to point GRUB to the proper config location';
  ## . End STAGE 3: Prepare /boot }

  ## Begin STAGE 4: Create subvolumes {
  # /btrfs_boot is already mounted at this point
  mount /btrfs_main || _exitALERT 'Failed to mount /btrfs_main';
  _subvolume_list=(
    "${_snapshotBootDir}"
    "${_snapshotMainDir}"
    '/btrfs_main/@libvirt-machines'
    '/btrfs_main/@libvirt-machines/@etc-libvirt'
    '/btrfs_main/@libvirt-machines/@var-lib-libvirt'
  );

  for _subvolume_id in "${_subvolume_list[@]}"; do
    btrfs subvolume create "${_subvolume_id}" \
      || _exitEMERG "Failed to create ${_subvolume_id}";
  done

  #####
  # STAGE 5: Finish additional mounts

  # At this point, /boot, /boot/efi, /btrfs_main, and /btrfs_boot are mounted.
  # /etc/libvirt and /var/lib/libvirt are not mounted.
  mount /etc/libvirt     || _exitALERT 'Failed to mount /etc/libvirt';
  mount /var/lib/libvirt || _exitALERT 'Failed to mount /var/lib/libvirt';

  _isPreparingSystem='n';
}

_restoreSnapshotFn () {
  declare _target_snapshot _snapshot_path _boot_snapshot_path \
    _snapshot_disp_id;

  _target_snapshot="${1:-}";
  if [ -z "${_target_snapshot}" ]; then
    _exitERR 'No snapshot name provided to restore!';
  fi
  _checkBtrfsStatusSetUpFn;
  _snapshot_path="${_snapshotMainDir}/${_target_snapshot}";
  _boot_snapshot_path="${_snapshotBootDir}/${_target_snapshot}";

  if [ -e '/btrfs_main/@kfocus-rollback-working' ] || \
    [ -e '/btrfs_boot/@kfocus-rollback-working-boot' ]; then
    _cm2WarnStrFn 'Temporary restore subvols found, cannot continue.';
    _cm2WarnStrFn 'Please reboot, then run "Finish restoration operation".';
    _exitERR 'Restore already in progress';
  fi

  if ! [ -e "${_snapshot_path}" ]; then
    _exitERR 'Expected snapshot path does not exist';
  fi

  _snapshot_disp_id="$(_rb2MakeSnapshotDispIdFn "${_target_snapshot}")";

  mv '/btrfs_main/@' '/btrfs_main/@kfocus-rollback-working' || _exitCRIT;
  btrfs subvolume snapshot "${_snapshot_path}" '/btrfs_main/@' || _exitEMERG;
  btrfs filesystem sync '/btrfs_main' || _exitEMERG;
  # Failing to unmount /boot/efi before attempting to move the old subvol
  # will result in the subvol not being moved, which will result in the
  # whole @boot subvol being nuked except for the contents of /boot/efi.
  umount /boot/efi || _exitALERT;
  mv '/btrfs_boot/@boot' '/btrfs_boot/@kfocus-rollback-working-boot' \
    || _exitALERT;
  btrfs subvolume snapshot "${_boot_snapshot_path}" '/btrfs_boot/@boot' \
    || _exitEMERG;
  btrfs filesystem sync '/btrfs_boot' || _exitEMERG;
  sync;
  mount /boot/efi || _exitALERT;

  # Let the user know that a restore has completed
  echo "${_snapshot_disp_id}" \
    > /btrfs_main/@/var/lib/kfocus/kfocus_rollback_restore_complete \
    || _exitALERT;
}

_deleteSnapshotFn () {
  declare _target_snapshot _snapshot_path _boot_snapshot_path;

  _target_snapshot="${1:-}";
  if [ -z "${_target_snapshot}" ]; then
    _exitERR 'No snapshot name provided to delete!';
  fi

  _checkBtrfsStatusSetUpFn;
  # This intentionally does not have the @ before ${_target_snapshot} because
  # the function is passed a snapshot name, not just a timestamp.
  _snapshot_path="${_snapshotMainDir}/${_target_snapshot}";
  _boot_snapshot_path="${_snapshotBootDir}/${_target_snapshot}";

  if ! [ -e "${_snapshot_path}" ]; then
    _exitERR;
  fi
  if ! [ -e "${_boot_snapshot_path}" ]; then
    _exitERR;
  fi

  btrfs subvolume delete --commit-after "${_snapshot_path}" || _exitEMERG;
  btrfs subvolume delete --commit-after "${_boot_snapshot_path}" || _exitEMERG;
}

_finalizeRestoreFn () {
  _checkBtrfsStatusSetUpFn;

  if ! mount | grep 'btrfs' | grep -q '@kfocus-rollback-working' \
    && ! mount | grep 'btrfs' | grep -q '@kfocus-rollback-working-boot'; then
    if [ -d '/btrfs_main/@kfocus-rollback-working' ]; then
      btrfs subvolume delete --commit-after '/btrfs_main/@kfocus-rollback-working' || _exitEMERG;
    fi
    if [ -d '/btrfs_boot/@kfocus-rollback-working-boot' ]; then
      btrfs subvolume delete --commit-after '/btrfs_boot/@kfocus-rollback-working-boot' \
        || _exitEMERG;
    fi
  fi
}

_trimSnapshotsFn () {
  declare _snapshot_list _snapshot_remove_list _snapshot_remove_count \
    _snapshot_idx;

  _checkBtrfsStatusSetUpFn;

  readarray -t _snapshot_list <<< "$(
    _cm2LsFn "${_snapshotMainDir}" | sed 's/@//' | sort -n | sed 's/^/@/'
  )";

  if [ "${#_snapshot_list[@]}" -gt '5' ]; then
    _snapshot_remove_list=();
    _snapshot_remove_count=$((${#_snapshot_list[@]} - 5));
    for ((_snapshot_idx = 0; _snapshot_idx < _snapshot_remove_count; \
      _snapshot_idx++)); do
      _deleteSnapshotFn "${_snapshot_list[_snapshot_idx]}";
    done
  fi
}

_createSnapshotFn () {
  declare _snapshot_event_type _timestamp_str _prev_timestamp_str \
    _snapshot_path _boot_snapshot_path _hour_seconds _week_seconds;

  _checkBtrfsStatusSetUpFn;

  _hour_seconds=3600;
  _week_seconds=604800;

  _timestamp_str="$(date +%s)";
  _snapshot_path="${_snapshotMainDir}/@${_timestamp_str}";
  _boot_snapshot_path="${_snapshotBootDir}/@${_timestamp_str}";
  _prev_timestamp_str="$(
    _cm2LsFn "${_snapshotMainDir}" \
      | sed 's/@//' | sort -n | tail -n1
  )";
  _snapshot_event_type="${1:-}"

  rm '/tmp/kfocus-rollback-set-noaptlabel' 2>/dev/null;
  # Don't let a directory fake this out unless it has contents
  rmdir '/tmp/kfocus-rollback-set-noaptlabel' 2>/dev/null;

  case "${_snapshot_event_type}" in
    'Apt')
      if (( ( _timestamp_str - _prev_timestamp_str ) < _hour_seconds )); then
        touch '/tmp/kfocus-rollback-set-noaptlabel';
        _exitNOTICE 'Too little time has elapsed for another snapshot';
      fi
      ;;
    'Timed')
      if (( ( _timestamp_str - _prev_timestamp_str ) < _week_seconds )); then
        _exitNOTICE 'Too little time has elapsed for another snapshot';
      fi
      ;;
  esac

  echo "${_snapshot_event_type}" \
    > '/var/lib/kfocus/kfocus_rollback_snapshot_reason';

  # This should theoretically never happen, but there's a non-zero chance
  # that it could if the user changes their clock backwards.
  #
  # TODO: There's a time-of-check to time-of-use bug here, I don't *think*
  # we care but review to see if this should be worked around.
  #
  if [ -e "${_snapshot_path}" ]; then
    _exitERR "Snapshot path |${_snapshot_path}| already exists!";
  fi
  if [ -e "${_boot_snapshot_path}" ]; then
    _exitERR "Boot snapshot path |${_snapshot_path}| already exists!";
  fi

  btrfs subvolume snapshot -r '/btrfs_main/@' "${_snapshot_path}" \
    || _exitEMERG "Could not create snapshot |${_snapshot_path}|";
  btrfs filesystem sync '/btrfs_main' || _exitEMERG;
  btrfs subvolume snapshot -r '/btrfs_boot/@boot' "${_boot_snapshot_path}" \
    || _exitEMERG "Could not create boot snapshot |${_boot_snapshot_path}|";
  btrfs filesystem sync '/btrfs_boot' || _exitEMERG;
  sync;
}

_systemRollbackFn () {
  declare _older_snapshot_list_str _restore_snapshot_str;

  # Any snapshots that are at number 5 or older will end up trimmed if we
  # don't purposefully exclude them, so get the list of all but the four
  # newest snapshots and exclude them a bit later.
  _older_snapshot_list_str="$(_getSnapshotListStrFn | tail -n+5)";
  _restore_snapshot_str="${1:-}";

  _createSnapshotFn 'Pre-Rollback' || exit;
  # Exclude the fifth and older snapshots.
  if ! [[ "${_older_snapshot_list_str}" =~ ${_restore_snapshot_str} ]]; then
    _trimSnapshotsFn || exit;
  fi
  _restoreSnapshotFn "${1:-}" || exit;
}

_systemSnapshotFn () {
  _createSnapshotFn "${1:-}" || _exitERR 'Could not create snapshot';
  _trimSnapshotsFn           || _exitERR 'Could not trim snapshots';
}

## BEGIN _mainFn {
#
_mainFn () {
  declare _main_min_space _boot_min_space _main_space \
    _boot_space _mode;

  _chkSetFlockFn;
  _checkBtrfsStatusFn;

  if [ "${_btrfsStatus}" = 'INCONSISTENT' ]; then
    _promptAllUsersFn 'warning' "${_inconsistentMsg}";
    _exitERR;
  fi

  (( _main_min_space = ( ( $(
      LC_ALL='C' df / \
        | tail -n1 \
        | awk '{ print $2 }'
    ) * 1024 ) / 100 ) * 15 ));
  _boot_min_space=1073741824 # 1 GiB
  _main_space="$(LC_ALL=C btrfs filesystem usage -b /btrfs_main \
    | awk '/Free \(estimated\)/{ print $3 }')";
  _boot_space="$(LC_ALL=C btrfs filesystem usage -b /btrfs_boot \
    | awk '/Free \(estimated\)/{ print $3 }')";

  if [ -d '/btrfs_main' ] && [ -d '/btrfs_boot' ]; then
    if (( _main_space < _main_min_space )) \
      || (( _boot_space < _boot_min_space )); then
      _promptAllUsersFn 'info' "${_lowDiskMsg}";
      _exitERR;
    fi
  fi

  _mode="${1:-}";

  case "${_mode}" in
    'createSnapshot')    _createSnapshotFn    "${2:-}";;
    'deleteSnapshot')    _deleteSnapshotFn    "${2:-}";;
    'finalizeRestore')   _finalizeRestoreFn;;
    'getBtrfsStatus')    echo "${_btrfsStatus}";;
    'prepareSystem')     _prepareSystemFn;;
    'restoreSnapshot')   _restoreSnapshotFn   "${2:-}";;
    'systemRollback')    _systemRollbackFn    "${2:-}";;
    'systemSnapshot')    _systemSnapshotFn    "${2:-}";;
    'trimSnapshots')     _trimSnapshotsFn;;
    *)
      _cm2WarnStrFn 'Invalid mode specified.';
      _exitERR;
      ;;
  esac

  _exitCleanFn;
}
## . END _mainFn }

## BEGIN Declare and assign global vars {
declare _binName _binDir _baseName _baseDir _lockFile _btrfsStatus _libTable \
  _browStr _erowStr _tableStr _prepareFailMsg _lowDiskMsg _inconsistentMsg \
  _isPreparingSystem _snapshotMainDir _snapshotBootDir;

_snapshotMainDir='/btrfs_main/@kfocus-rollback-snapshots';
_snapshotBootDir='/btrfs_boot/@kfocus-rollback-boot-snapshots';

# Set flag for error reporting
_isPreparingSystem='n';
## . END Declare and assign global vars }

## BEGIN Run mainFn when script is NOT sourced {
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  _binName="$(  readlink -f "$0"       )" || exit 101;
  _binDir="$(   dirname  "${_binName}" )" || exit 101;
  _baseDir="$(  dirname  "${_binDir}"  )" || exit 101;
  _baseName="$( basename "${_binName}" )" || exit 101;
  _lockFile="/tmp/kfocus-rollback-backend.lock";
  _btrfsStatus='';

  # Import libs
  _libTable=(
    '/usr/lib/kfocus/lib/common.2.source'
    '/usr/lib/kfocus/lib/rollback.2.source'
  );

  _loadLibTableFn "${_libTable[@]}" || exit 1;

  # Set error messages
  _browStr='<tr><td style="padding:8px 32px 8px 0">';
  _erowStr='</td></tr>';
  _tableStr='<table style="width:100%;margin-right:32px">';

  _prepareFailMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">Critical Error</h3>${_erowStr}

${_browStr}FocusRx was interrupted while attempting to set up system file
snapshotting. This incident may be the result of failing
hardware or a software conflict.${_erowStr}

${_browStr}<b>Please report this issue to technical support. This is not
normal and should never happen.</b>${_erowStr}</table>
${_cm2HtmEndStr}
EOF
  )";

  _lowDiskMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">Low Disk Space</h3>${_erowStr}

${_browStr}Your system is running low on disk space. This could result in
filesystem corruption if not corrected. It is highly recommended
that you use the Drive Optimizer to clear some space. You may also
need to delete excess files or move them to other drives. You can
access the Drive Optimizer by clicking <code>Start Menu >
Kubuntu Focus Tools > Drive Optimizer</code>.${_erowStr}

${_browStr}For your safety, no snapshot-related actions have been
performed.${_erowStr}</table>
${_cm2HtmEndStr}
EOF
  )";

  _inconsistentMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">Inconsistent FS Layout</h3>${_erowStr}

${_browStr}This system's filesystem layout appears to have been modified from
its default configuration. System snapshots and system rollback
are incompatible with the current filesystem state.${_erowStr}

${_browStr}Please correct the filesystem layout at your earliest convenience.
See ??? for more information.${_erowStr}</table>
${_cm2HtmEndStr}
EOF
  )";

  _mainFn "$@";
fi
## . END Run mainFn when script is NOT sourced }
