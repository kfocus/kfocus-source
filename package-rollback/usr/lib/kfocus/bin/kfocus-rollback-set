#!/bin/bash
#
# Copyright 2022-2024 MindShare Inc.
#
# Written for the Kubuntu Focus by A. Rainbolt and M. Mikowski
#
# Name     : kfocus-rollback-set
# Summary  : kfocus-rollback-set (createSnapshot
#              <Apt|Timed|Pre-Rollback|(username)>
#              | restoreSnapshot @<timestamp> | deleteSnapshot @<timestamp>
#              | labelAptSnapshot | finalizeRestore  | trimSnapshots
#              | prepareSystem    | getBtrfsStatus
#              | systemSnapshot
# Purpose  : Performs snapshot management operations
# Example  : kfocus-rollback-set restoreSnapshot @1234
# License  : GPLv2
# Run By   : kfocus-rollback, kfocus-snapshot, system processes
# Spec     : 4013
# Note     : WORK IN PROGRESS, DO NOT USE IN PRODUCTION
#
set -u;

_stderrFn () {
  2>&1 echo "${_baseName} $*";
}
## BEGIN _loadLibTableFn {
# Summary : _loadLibTableFn <lib_str1> <lib_str2> ...
# Example : _loadLibTableFn "lib01:/usr/lib/lib01" "lib02";
# Purpose :
#   Import table of libs, one arg per lib.
#     * Each arg can have alternates delimited by colons ':'
#     * Fails if all alternates for a lib fails.
#     * Starting lib string '#:' means the following libs are optional.
#     * Diagnostics are sent to STDERR.
#     * Libs without a directory use ${_binDir} as the path
#
_loadLibTableFn () {
  declare _lib_table _lib_list _lib_line _raw_path _lib_file _is_loaded;
  _lib_table=("$@");

  ## Begin: Iterate over lib lines.
  for _lib_line in "${_lib_table[@]}"; do
    # Split line into alternates.
    #   Note: Echo removes trailing newline.
    readarray -d: -t _lib_list < <(echo -n "${_lib_line}");
    _is_loaded='n';

    ## Begin: Iterate over alternates.
    for _raw_path in "${_lib_list[@]}"; do
      [ -z "$(dirname "${_raw_path}")" ] \
        && _lib_file="${_binDir}/${_raw_path}" \
        || _lib_file="${_raw_path}";

      # shellcheck disable=SC1090
      if ! [ -r "${_lib_file}" ]; then
        _stderrFn "warn: source |${_lib_file}| not readable.";
      elif source "${_lib_file}"; then
        _is_loaded='y';
        break;
      else
        _stderrFn "${_baseName} Error: source |${_lib_file}| is non-zero.";
        return 1;
      fi
    done
    ## . End: Iterate over alternates.

    if [ "${_is_loaded}" != 'y' ]; then
      _stderrFn "${_baseName} error: no lib loaded";
      return 1;
    fi
  done
  ## . End: Iterate over lib lines.

  return;
}
## . END _loadLibTableFn }

## BEGIN Define error and exit handling {
_trapExitFn () {
  1>&2 echo "${_baseName} was interrupted";
  if [ "${_isPreparingSystem}" = 'y' ]; then
    _promptAllUsersFn 'error' "${_prepareFailMsg}";
  fi
  rm "${_lockFile}" || true;
}

_chkSetFlockFn () {
  if ! [ -e "${_lockFile}" ]; then
    install -m 666 /dev/null "${_lockFile}";
  fi
  exec 211>"${_lockFile}" || {
    echo 'Lock file permission denied';
    return 21;
  };
  if ! flock -n -e 211; then
    1>&2 echo "Cannot get lock on ${_lockFile}";
    return 20;
  fi
  # Trap unexpected exits to clean up lock file
  trap _trapExitFn EXIT;
}

_exitCleanFn () {
  declare _int;
  _int="$(_cm2EchoIntFn "${1:-0}")";
  trap '' EXIT;
  rm "${_lockFile}" || true;
  exit "${_int}";
}

_exitWithCodeFn () {
  declare _int _msg;

  _int="$(_cm2EchoIntFn "${1:-0}")";
  _msg="${2:-}";

  if [ -n "${_msg}" ]; then
    1>&2 echo "${_msg}";
  fi
  _exitCleanFn "${_int}";
}

_exitNOTICE () { _exitWithCodeFn  0 "$@"; }
_exitERR ()    { _exitWithCodeFn  1 "$@"; }
_exitCRIT ()   { _exitWithCodeFn  2 "$@"; }
_exitALERT ()  { _exitWithCodeFn  3 "$@"; }
_exitEMERG ()  { _exitWithCodeFn  4 "$@"; }
## . END Define error and exit handling }

## BEGIN _promptAllUsersFn {
# See https://stackoverflow.com/a/49533938
_promptAllUsersFn () {
  declare _mode _msg _xserver_id _user_name;
  _mode="${1:-info}";
  _msg="${2:-blank}";

  while read -r _xserver_id; do
    _user_name="$(
      who | grep "(:${_xserver_id})" | head -n1 | awk '{ print $1 }'
    )";
    if [ -z "${_user_name}" ]; then continue; fi

    sudo -u "${_user_name}" \
      DISPLAY="${_xserver_id}" \
      DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$(id -u "${_user_name}")/bus" \
      qdbus org.kfocus.FocusRxDispatch.launcher / "${_mode}" "${_msg}";
  done < <(_cm2LsFn '/tmp/.X11-unix/' | sed 's?/tmp/.X11-unix/X??')
}
## . END _promptAllUsersFn }

## BEGIN _checkRootFn {
#
_checkRootFn () {
  declare _uid;
  _uid="$(id -u)";
  if [ "${_uid}" = '0' ]; then
    return 0;
  else
    _cm2WarnStrFn 'This action requires root privileges.';
    return 1;
  fi
}
## . END _checkRootFn }

## BEGIN _clearRestoreFn {
_clearRestoreFn () {
  rm -f "${_restoreCompleteFile}" || true;
}
## . END _clearRestoreFn }

## BEGIN BTRFS maintenance helper functions {
#
_getMainUsageReportFn () {
  LC_ALL='C' "${_btrfsExe}" filesystem usage -b '/btrfs_main';
}

_getBootUsageReportFn () {
  LC_ALL='C' "${_btrfsExe}" filesystem usage -b '/btrfs_boot';
}

_getMainBtduReportFn () {
  LC_ALL='C' "${_btduExe}" --du --min-resolution=1M --headless '/btrfs_main'
}

_getMainFragReportFn () {
  "${_filefragExe}" '/btrfs_main/@';
}
## . END BTRFS maintenance helper functions }

## BEGIN _checkBtrfsStatusFn {
#
_checkBtrfsStatusFn () {
  declare _main_fs _boot_fs _main_subvols_str _boot_subvols_str;

  # The presence of /var/lib/portables or /var/lib/machines subvolumes will
  # interfere with snapshotting. These subvolumes may be created automatically
  # by systemd if it is not configured otherwise.
  if grep -q 'var/lib/portables' < <("${_btrfsExe}" subvolume list /) || \
     grep -q 'var/lib/machines' < <("${_btrfsExe}" subvolume list /); then
    if [ -n "$(ls -A /var/lib/portables)" ] || \
       [ -n "$(ls -A /var/lib/machines )" ]; then
      _btrfsStatus='UNSUPPORTED';
    fi
  fi

  if [ -d '/btrfs_main' ] && [ -d '/btrfs_boot' ]; then
    if [ -d '/btrfs_main/@' ] \
      && [ -d "${_snapshotMainDir}" ] \
      && [ -d '/btrfs_boot/@boot' ] \
      && [ -d "${_snapshotBootDir}" ]; then
      _main_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on / ' \
        | cut -d' ' -f1)";
      _boot_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on /boot ' \
        | cut -d' ' -f1)";
      if [ -n "${_main_fs}" ] && [ -n "${_boot_fs}" ] \
        && [ "${_main_fs}" != "${_boot_fs}" ]; then
        _btrfsStatus='SUPPORTED, SET UP';
      else
        _btrfsStatus='UNSUPPORTED';
      fi
    else
      _btrfsStatus='UNSUPPORTED';
    fi
  else
    if ! [ -d '/btrfs_main' ] && ! [ -d '/btrfs_boot' ]; then
      _main_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on / ' \
        | cut -d' ' -f1)";
      _boot_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on /boot ' \
        | cut -d' ' -f1)";
      if [ -n "${_main_fs}" ] && [ -n "${_boot_fs}" ] \
        && [ "${_main_fs}" != "${_boot_fs}" ]; then
        _main_subvols_str="$("${_btrfsExe}" subvolume list / | awk '{ print $9 }' | sort)";
        _boot_subvols_str="$("${_btrfsExe}" subvolume list /boot | awk '{ print $9 }' | sort)";
        if grep -E '^@$' <<< "${_main_subvols_str}" && \
          LC_ALL='C' mount | grep -q ' on /home '; then
          if [ -z "${_boot_subvols_str}" ]; then
            if ! grep -E '^@kfocus-rollback-snapshots$' \
              <<< "${_main_subvols_str}"; then
              _btrfsStatus='SUPPORTED, NOT SET UP';
            else
              _btrfsStatus='INCONSISTENT';
            fi
          else
            _btrfsStatus='UNSUPPORTED';
          fi
        else
          _btrfsStatus='UNSUPPORTED';
        fi
      else
        _btrfsStatus='UNSUPPORTED';
      fi
    else
      _btrfsStatus='INCONSISTENT';
    fi
  fi
}
## . END _checkBtrfsStatusFn }

## BEGIN _checkBtrfsStatusSetUpFn {
#
_checkBtrfsStatusSetUpFn () {
  if ! [ "${_btrfsStatus}" = 'SUPPORTED, SET UP' ]; then
    _exitNOTICE "${_btrfsStatus}";
  fi
}
## . END _checkBtrfsStatusSetUpFn }

## BEGIN _getSnapshotListStrFn {
#
_getSnapshotListStrFn () {
  # TODO 2024-04-05 mmikowski warm: use _cm2LsFn instead here
  find "${_snapshotMainDir}" -maxdepth 1 \
    | cut -d'@' -f3 \
    | sort -n -r \
    | sed '/^$/d; s/^/@/;';
}
## . END _getSnapshotListStrFn }

## BEGIN _prepareSystemFn () {
#
_prepareSystemFn () {
  declare _root_mount_id _boot_mount_id _btrfs_defaults_str \
    _dir _subvolume_list _subvolume_id;

  _isPreparingSystem='y';

  ## Begin STAGE 1: Check and prep filesystem {
  if [ "${_btrfsStatus}" = 'SUPPORTED, SET UP' ]; then
    _exitNOTICE 'This system already appears snapshot-enabled.';
  fi

  if [ "${_btrfsStatus}" = 'UNSUPPORTED' ]; then
    _exitERR 'This system does not support snapshotting.';
  fi

  # Check libvirt dirs, if they have content do not proceed
  if [ -d '/etc/libvirt' ] || [ -d '/var/lib/libvirt' ]; then
    if [ -n "$(ls -A /etc/libvirt     2>/dev/null)" ] || \
       [ -n "$(ls -A /var/lib/libvirt 2>/dev/null)" ]; then
      _exitERR 'Cannot create libvirt subvols, libvirt is installed!';
    fi
  fi

  # systemd may create /var/lib/portables and /var/lib/machines BTRFS
  # subvolumes of its own accord if not configured otherwise. Ensure that
  # these are not present.
  "${_btrfsExe}" subvolume delete --commit-after '/var/lib/portables' || true;
  "${_btrfsExe}" subvolume delete --commit-after '/var/lib/machines'  || true;

  # Create directories
  for _dir in '/btrfs_boot' '/btrfs_main' '/etc/libvirt' '/var/lib/libvirt'; do
    mkdir -p "${_dir}" || _exitCRIT "Cannot create ${_dir}";
  done;
  ## . End STAGE 1: Check and prep filesystem }

  ## Begin STAGE 2: Adjust fstab {
  _root_mount_id="$(LC_ALL=C mount | grep ' on / ' | cut -d' ' -f1)";
  _root_mount_id="UUID=$(LC_ALL=C lsblk -o NAME,FSTYPE,UUID,MOUNTPOINTS \
    "${_root_mount_id}" | sed -n '2p' | awk '{ print $3 }')";
  _boot_mount_id="UUID=$(LC_ALL=C lsblk -o NAME,FSTYPE,UUID,MOUNTPOINTS \
    | grep -P '/boot$' | awk '{ print $3 }')";
  _btrfs_defaults_str="defaults,noatime,autodefrag 0 0";

  echo "${_root_mount_id} /btrfs_main btrfs subvolid=5,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /btrfs_main';
  echo "${_boot_mount_id} /btrfs_boot btrfs subvolid=5,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /btrfs_boot';
  echo "${_root_mount_id} /etc/libvirt btrfs subvol=@libvirt-machines/@etc-libvirt,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /etc/libvirt';
  echo "${_root_mount_id} /var/lib/libvirt btrfs subvol=@libvirt-machines/@var-lib-libvirt,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /var/lib/libvirt';
  ## . End STAGE 2: Adjust fstab }

  ## Begin STAGE 3: Prepare /boot {
  # Unmount boot-related directories, so we can rearrange their contents
  umount /boot/efi || _exitALERT 'Failed to unmount /boot/efi';
  umount /boot     || _exitALERT 'Failed to unmount /boot';

  # Point fstab at a soon-to-be-created @boot subvolume.
  sed -i '/\/boot /s/defaults/subvol=\/@boot,defaults/' /etc/fstab \
    || _exitALERT 'Failed to update fstab for @boot';

  # Reload fstab changes
  systemctl daemon-reload;

  # Morph the layout of the boot partition
  mount /btrfs_boot || _exitALERT 'Failed to mount /btrfs_boot';
  "${_btrfsExe}" subvolume create /btrfs_boot/@boot \
    || _exitEMERG 'Failed to create @boot';

  # This will always throw a warning about not being able to move a directory
  # into itself, therefore we have to ignore it
  mv /btrfs_boot/* /btrfs_boot/@boot/ 2>/dev/null || true;

  # Mount /boot again after successful rearrange
  mount /boot     || _exitALERT 'Failed to mount /boot';
  mount /boot/efi || _exitALERT 'Failed to mount /boot/efi';

  # Point the primary grub.cfg at the new boot files
  update-grub || _exitALERT 'Failed to update GRUB configuration';

  # Make sure GRUB can find the primary grub.cfg at its new location
  sed -i "s/'\/grub'/'\/@boot\/grub'/" /boot/efi/EFI/ubuntu/grub.cfg \
    || _exitALERT 'Failed to point GRUB to the proper config location';
  ## . End STAGE 3: Prepare /boot }

  ## Begin STAGE 4: Create subvolumes {
  # /btrfs_boot is already mounted at this point
  mount /btrfs_main || _exitALERT 'Failed to mount /btrfs_main';
  _subvolume_list=(
    "${_snapshotBootDir}"
    "${_snapshotMainDir}"
    '/btrfs_main/@libvirt-machines'
    '/btrfs_main/@libvirt-machines/@etc-libvirt'
    '/btrfs_main/@libvirt-machines/@var-lib-libvirt'
  );

  for _subvolume_id in "${_subvolume_list[@]}"; do
    "${_btrfsExe}" subvolume create "${_subvolume_id}" \
      || _exitEMERG "Failed to create ${_subvolume_id}";
  done
  ## . END Stage 4: Create subvolumes }

  ## Begin STAGE 5: Finish additional mounts {
  # At this point, /boot, /boot/efi, /btrfs_main, and /btrfs_boot are mounted.
  # /etc/libvirt and /var/lib/libvirt are not mounted.
  mount /etc/libvirt     || _exitALERT 'Failed to mount /etc/libvirt';
  mount /var/lib/libvirt || _exitALERT 'Failed to mount /var/lib/libvirt';
  ## . END STAGE 5: Finish additional mounts }

  _isPreparingSystem='n';
}
## . END _prepareSystemFn }

## BEGIN _checkWarnDiskSpaceFn {
#
_checkWarnDiskSpaceFn () {
  declare _main_space_report _main_min_space _boot_min_space \
    _main_min_unalloc _main_space _main_unalloc _boot_space;

  _checkBtrfsStatusSetUpFn;

  # TODO: Take unallocated space into account here, not just estimated free
  # space
  (( _main_min_space = ( ( $(
      LC_ALL='C' df / \
        | tail -n1 \
        | awk '{ print $2 }'
    ) * 1024 ) / 100 ) * 15 ));
  _main_min_unalloc=21474836480 # 20 GiB
  _boot_min_space=1073741824 # 1 GiB
  _main_space_report="$(LC_ALL=C "${_btrfsExe}" filesystem usage -b \
    /btrfs_main)";
  _main_space="$(awk '/Free \(estimated\)/{ print $3 }' \
    <<< "${_main_space_report}")";
  _main_unalloc="$(awk '/Device unallocated/{ print $3 }' \
    <<< "${_main_space_report}")";
  _boot_space="$(LC_ALL=C "${_btrfsExe}" filesystem usage -b /btrfs_boot \
    | awk '/Free \(estimated\)/{ print $3 }')";
 
  if [ -d '/btrfs_main' ] && [ -d '/btrfs_boot' ]; then
    if (( _main_space < _main_min_space )) \
      || (( _main_unalloc < _main_min_unalloc )) \
      || (( _boot_space < _boot_min_space )); then
      _promptAllUsersFn 'info' "${_lowDiskMsg}";
      _exitERR;
    fi
  fi
}
## . END _checkWarnDiskSpaceFn }

## BEGIN _deleteSnapshotFn {
#
_deleteSnapshotFn () {
  declare _target_snapshot _snapshot_path _boot_snapshot_path;

  _target_snapshot="${1:-}";
  if [ -z "${_target_snapshot}" ]; then
    _exitERR 'No snapshot name provided to delete!';
  fi

  _checkBtrfsStatusSetUpFn;
  # This intentionally does not have the @ before ${_target_snapshot} because
  # the function is passed a snapshot name, not just a timestamp.
  _snapshot_path="${_snapshotMainDir}/${_target_snapshot}";
  _boot_snapshot_path="${_snapshotBootDir}/${_target_snapshot}";

  if ! [ -e "${_snapshot_path}" ] && ! [ -e "${_boot_snapshot_path}" ]; then
    _exitERR;
  fi

  if [ -e "${_snapshot_path}" ]; then
    "${_btrfsExe}" subvolume delete --commit-after "${_snapshot_path}" || _exitEMERG;
  fi
  if [ -e "${_boot_snapshot_path}" ]; then
    "${_btrfsExe}" subvolume delete --commit-after "${_boot_snapshot_path}" || _exitEMERG;
  fi
}
## . END _deleteSnapshotFn }

## BEGIN _finalizeRestoreFn {
#
_finalizeRestoreFn () {
  _checkBtrfsStatusSetUpFn;

  if ! mount | grep 'btrfs' | grep -q '@kfocus-rollback-working' \
    && ! mount | grep 'btrfs' | grep -q '@kfocus-rollback-working-boot'; then
    if [ -d '/btrfs_main/@kfocus-rollback-working' ]; then
      "${_btrfsExe}" subvolume delete --commit-after '/btrfs_main/@kfocus-rollback-working' || _exitEMERG;
    fi
    if [ -d '/btrfs_boot/@kfocus-rollback-working-boot' ]; then
      "${_btrfsExe}" subvolume delete --commit-after '/btrfs_boot/@kfocus-rollback-working-boot' \
        || _exitEMERG;
    fi
  fi
}
## . END _finalizeRestoreFn }

## BEGIN _trimSnapshotsFn {
#
_trimSnapshotsFn () {
  declare _main_snapshot_list _boot_snapshot_list _snapshot_id \
    _snapshot_remove_count _snapshot_idx;

  _checkBtrfsStatusSetUpFn;

  readarray -t _main_snapshot_list <<< "$(
    _cm2LsFn "${_snapshotMainDir}" | sed 's/@//' | sort -n | sed 's/^/@/'
  )";
  readarray -t _boot_snapshot_list <<< "$(
    _cm2LsFn "${_snapshotBootDir}" | sed 's/@//' | sort -n | sed 's/^/@/'
  )";

  for _snapshot_id in "${_main_snapshot_list[@]}"; do
    if ! [[ " ${_boot_snapshot_list[*]} " \
      =~ [[:space:]]${_snapshot_id}[[:space:]] ]]; then
      _deleteSnapshotFn "${_snapshot_id}";
    fi
  done

  for _snapshot_id in "${_boot_snapshot_list[@]}"; do
    if ! [[ " ${_main_snapshot_list[*]} " \
      =~ [[:space:]]${_snapshot_id}[[:space:]] ]]; then
      _deleteSnapshotFn "${_snapshot_id}";
    fi
  done

  readarray -t _main_snapshot_list <<< "$(
    _cm2LsFn "${_snapshotMainDir}" | sed 's/@//' | sort -n | sed 's/^/@/'
  )";

  if [ "${#_main_snapshot_list[@]}" -gt '5' ]; then
    _snapshot_remove_count=$((${#_main_snapshot_list[@]} - 5));
    for ((_snapshot_idx = 0; _snapshot_idx < _snapshot_remove_count; \
      _snapshot_idx++)); do
      _deleteSnapshotFn "${_main_snapshot_list[_snapshot_idx]}";
    done
  fi
}
## . END _trimSnapshotsFn }

## BEGIN _createSnapshotFn {
#
_createSnapshotFn () {
  declare _snapshot_event_type _timestamp_str _prev_timestamp_str \
    _snapshot_path _boot_snapshot_path _hour_seconds _week_seconds;

  _checkBtrfsStatusSetUpFn;

  _hour_seconds=3600;
  _week_seconds=604800;

  _timestamp_str="$(date +%s)";
  _snapshot_path="${_snapshotMainDir}/@${_timestamp_str}";
  _boot_snapshot_path="${_snapshotBootDir}/@${_timestamp_str}";
  _prev_timestamp_str="$(
    _cm2LsFn "${_snapshotMainDir}" \
      | sed 's/@//' | sort -n | tail -n1
  )";
  _snapshot_event_type="${1:-}"

  case "${_snapshot_event_type}" in
    'Apt')
      if (( ( _timestamp_str - _prev_timestamp_str ) < _hour_seconds )); then
        _exitNOTICE 'Too little time has elapsed for another snapshot';
      fi
      ;;
    'Timed')
      if (( ( _timestamp_str - _prev_timestamp_str ) < _week_seconds )); then
        _exitNOTICE 'Too little time has elapsed for another snapshot';
      fi
      ;;
  esac

  echo "${_snapshot_event_type}" \
    > '/var/lib/kfocus/kfocus_rollback_snapshot_reason';

  # This should theoretically never happen, but there's a non-zero chance
  # that it could if the user changes their clock backwards.
  #
  # TODO: There's a time-of-check to time-of-use bug here, I don't *think*
  # we care but review to see if this should be worked around.
  #
  if [ -e "${_snapshot_path}" ]; then
    _exitERR "Snapshot path |${_snapshot_path}| already exists!";
  fi
  if [ -e "${_boot_snapshot_path}" ]; then
    _exitERR "Boot snapshot path |${_snapshot_path}| already exists!";
  fi

  "${_btrfsExe}" subvolume snapshot -r '/btrfs_main/@' "${_snapshot_path}" \
    || _exitEMERG "Could not create snapshot |${_snapshot_path}|";
  "${_btrfsExe}" filesystem sync '/btrfs_main' || _exitEMERG;
  "${_btrfsExe}" subvolume snapshot -r '/btrfs_boot/@boot' "${_boot_snapshot_path}" \
    || _exitEMERG "Could not create boot snapshot |${_boot_snapshot_path}|";
  "${_btrfsExe}" filesystem sync '/btrfs_boot' || _exitEMERG;
  sync;
}
## . END _createSnapshotFn

## BEGIN _restoreSnapshotFn {
#
_restoreSnapshotFn () {
  declare _older_snapshot_list_str _target_snapshot _snapshot_path \
    _boot_snapshot_path _snapshot_disp_id;

  _checkBtrfsStatusSetUpFn;

  # Any snapshots that are at number 5 or older will end up trimmed if we
  # don't purposefully exclude them, so get the list of all but the four
  # newest snapshots and exclude them a bit later.
  _older_snapshot_list_str="$(_getSnapshotListStrFn | tail -n+5)";
  _target_snapshot="${1:-}";

  if [ -z "${_target_snapshot}" ]; then
    _exitERR 'No snapshot name provided to restore!';
  fi

  _createSnapshotFn 'Pre-Rollback' || exit;
  # Exclude the fifth and older snapshots.
  if ! [[ "${_older_snapshot_list_str}" =~ ${_target_snapshot} ]]; then
    _trimSnapshotsFn || exit;
  fi

  _snapshot_path="${_snapshotMainDir}/${_target_snapshot}";
  _boot_snapshot_path="${_snapshotBootDir}/${_target_snapshot}";

  if [ -e '/btrfs_main/@kfocus-rollback-working' ] || \
    [ -e '/btrfs_boot/@kfocus-rollback-working-boot' ]; then
    _cm2WarnStrFn 'Temporary restore subvols found, cannot continue.';
    _cm2WarnStrFn 'Please reboot, then run "Finish restoration operation".';
    _exitERR 'Restore already in progress';
  fi

  if ! [ -e "${_snapshot_path}" ] || ! [ -e "${_boot_snapshot_path}" ]; then
    _exitERR 'Expected snapshot path does not exist';
  fi

  _snapshot_disp_id="$(_rb2MakeSnapshotDispIdFn "${_target_snapshot}")";

  mv '/btrfs_main/@' '/btrfs_main/@kfocus-rollback-working' || _exitCRIT;
  "${_btrfsExe}" subvolume snapshot "${_snapshot_path}" '/btrfs_main/@' || _exitEMERG;
  "${_btrfsExe}" filesystem sync '/btrfs_main' || _exitEMERG;
  # Failing to unmount /boot/efi before attempting to move the old subvol
  # will result in the subvol not being moved, which will result in the
  # whole @boot subvol being nuked except for the contents of /boot/efi.
  umount /boot/efi || _exitALERT;
  mv '/btrfs_boot/@boot' '/btrfs_boot/@kfocus-rollback-working-boot' \
    || _exitALERT;
  "${_btrfsExe}" subvolume snapshot "${_boot_snapshot_path}" '/btrfs_boot/@boot' \
    || _exitEMERG;
  "${_btrfsExe}" filesystem sync '/btrfs_boot' || _exitEMERG;
  sync;
  mount /boot/efi || _exitALERT;

  # Let the user know that a restore has completed
  echo "${_snapshot_disp_id}" \
    > "/btrfs_main/@${_restoreCompleteFile}" || _exitALERT;
}
## . END _restoreSnapshotFn }

## BEGIN _systemSnapshotFn {
#
_systemSnapshotFn () {
  _checkBtrfsStatusSetUpFn;
  _createSnapshotFn "${1:-}" || _exitERR 'Could not create snapshot';
  _trimSnapshotsFn           || _exitERR 'Could not trim snapshots';
}
## . END _systemSnapshotFn }

_btrfsMaintainFn () {
  true; # TODO port from kfocus-btrfs-optimize-set
}

_btrfsDeepCleanFn () {
  true; # TODO port from kfocus-btrfs-optimize-set
}

## BEGIN _mainFn {
#
_mainFn () {
  declare _main_min_space _boot_min_space _main_space \
    _boot_space _mode;

  while ! _chkSetFlockFn; do
    sleep 1;
  done
  _checkBtrfsStatusFn;

  if [ "${_btrfsStatus}" = 'INCONSISTENT' ]; then
    _promptAllUsersFn 'warning' "${_inconsistentMsg}";
    _exitERR;
  fi

  (( _main_min_space = ( ( $(
      LC_ALL='C' df / \
        | tail -n1 \
        | awk '{ print $2 }'
    ) * 1024 ) / 100 ) * 15 ));
  _boot_min_space=1073741824 # 1 GiB
  _main_space="$(LC_ALL=C btrfs filesystem usage -b /btrfs_main \
    | awk '/Free \(estimated\)/{ print $3 }')";
  _boot_space="$(LC_ALL=C btrfs filesystem usage -b /btrfs_boot \
    | awk '/Free \(estimated\)/{ print $3 }')";

  if [ -d '/btrfs_main' ] && [ -d '/btrfs_boot' ]; then
    if (( _main_space < _main_min_space )) \
      || (( _boot_space < _boot_min_space )); then
      _promptAllUsersFn 'info' "${_lowDiskMsg}";
      _exitERR;
    fi
  fi

  _mode="${1:-}";

  case "${_mode}" in
    'checkWarnDiskSpace') _checkWarnDiskSpaceFn;;
    'clearRestore')       _clearRestoreFn;;
    'createSnapshot')     _createSnapshotFn    "${2:-}";;
    'deleteSnapshot')     _deleteSnapshotFn    "${2:-}";;
    'finalizeRestore')    _finalizeRestoreFn;;
    'getBtrfsStatus')     echo "${_btrfsStatus}";;
    'prepareSystem')      _prepareSystemFn;;
    'restoreSnapshot')    _restoreSnapshotFn   "${2:-}";;
    'systemSnapshot')     _systemSnapshotFn    "${2:-}";;
    'trimSnapshots')      _trimSnapshotsFn;;
    'btrfsMaintain')      _btrfsMaintainFn;;
    'btrfsDeepClean')     _btrfsDeepCleanFn;;
    *)
      _cm2WarnStrFn 'Invalid mode specified.';
      _exitERR;
      ;;
  esac

  _exitCleanFn;
}
## . END _mainFn }

## BEGIN Declare and assign global vars {
declare _binName _binDir _baseName _baseDir \
  _isPreparingSystem _lockFile _btrfsStatus \
  _snapshotMainDir _snapshotBootDir _restoreCompleteFile \
  _libTable _browStr _erowStr _tableStr _prepareFailMsg \
  _lowDiskMsg _inconsistentMsg _btrfsExe _btduExe _filefragExe;

_btrfsStatus='';
_isPreparingSystem='n'; # Flag for error reporting
_lockFile="/tmp/kfocus-rollback-backend.lock";
_restoreCompleteFile='/var/lib/kfocus/kfocus_rollback_restore_complete';
_snapshotBootDir='/btrfs_boot/@kfocus-rollback-boot-snapshots';
_snapshotMainDir='/btrfs_main/@kfocus-rollback-snapshots';

## . END Declare and assign global vars }

## BEGIN Run mainFn when script is NOT sourced {
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  _binName="$(  readlink -f "$0"       )" || exit 101;
  _binDir="$(   dirname  "${_binName}" )" || exit 101;
  _baseDir="$(  dirname  "${_binDir}"  )" || exit 101;
  _baseName="$( basename "${_binName}" )" || exit 101;

  # Import libs and assign more global vars
  _libTable=(
    "${_baseDir}/lib/common.2.source"
    "${_baseDir}/lib/rollback.2.source"
  );
  _loadLibTableFn "${_libTable[@]}" || exit 1;

  _assignList=(
    '_btrfsExe|/usr/bin/btrfs'
    '_btrfsBalanceExe|/usr/bin/btrfs-balance-least-used'
    '_btduExe|/usr/bin/btdu'
    "_filefragExe|${_binDir}/kfocus-report-filefrag"
  );

  if ! _cm2AssignExeVarsFn "${_assignList[@]}"; then
    _cm2ErrStrFn 'Could not assign variables';
    exit 1;
  fi

  # Set error messages
  _browStr='<tr><td style="padding:8px 32px 8px 0">';
  _erowStr='</td></tr>';
  _tableStr='<table style="width:100%;margin-right:32px">';

  _prepareFailMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">Critical Error</h3>${_erowStr}

${_browStr}FocusRx was interrupted while attempting to set up system<br>
file snapshotting. This incident may be the result of failing<br>
hardware or a software conflict.${_erowStr}

${_browStr}<b>Please report this issue to technical support. This is not<br>
normal and should never happen.</b>${_erowStr}</table>
${_cm2HtmEndStr}
EOF
  )";

  _lowDiskMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">Low Disk Space</h3>${_erowStr}

${_browStr}Your system is running low on disk space. This could result in<br>
filesystem corruption if not corrected. It is highly recommended<br>
that you use the Drive Optimizer to clear some space. You may<br>
also need to delete excess files or move them to other drives.<br>
You can access the Drive Optimizer by clicking <code>Start Menu &gt;<br>
Kubuntu Focus Tools &gt; Drive Optimizer</code>.${_erowStr}

${_browStr}For your safety, no snapshot-related actions have been
performed.${_erowStr}</table>
${_cm2HtmEndStr}
EOF
  )";

  _inconsistentMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">Inconsistent FS Layout</h3>${_erowStr}

${_browStr}This computer's file system layout was changed from the<br>
default. This breaks system snapshots and rollback.${_erowStr}

${_browStr}If you moved <code>/btrfs_main</code> or <code>/btrfs_boot</code>,
please move<br>
them back to their original locations. If you did not move<br>
either of these directories, please contact technical support.
${_erowStr}</table>
${_cm2HtmEndStr}
EOF
  )";

  _mainFn "$@";
fi
## . END Run mainFn when script is NOT sourced }
