#!/bin/bash
#
# Copyright 2022-2024 MindShare Inc.
#
# Written for the Kubuntu Focus by A. Rainbolt and M. Mikowski
#
# Name     : kfocus-rollback-backend
# Summary  : kfocus-rollback-backend <mode> [<args...>]
# Purpose  : Performs snapshot management operations
# Example  : kfocus-rollback-backend restoreSnapshot @1234
# License  : GPLv2
# Run By   : kfocus-rollback, system processes
# Spec     : 4013
#
# shellcheck source=../lib/common.2.source
# shellcheck source=../lib/rollback.2.source
#
set -u;

_stderrFn () {
  2>&1 echo "${_baseName} $*";
}
## BEGIN _loadLibTableFn {
# Summary : _loadLibTableFn <lib_str1> <lib_str2> ...
# Example : _loadLibTableFn "lib01:/usr/lib/lib01" "lib02";
# Purpose :
#   Import table of libs, one arg per lib.
#     * Each arg can have alternates delimited by colons ':'
#     * Fails if all alternates for a lib fails.
#     * Starting lib string '#:' means the following libs are optional.
#     * Diagnostics are sent to STDERR.
#     * Libs without a directory use ${_binDir} as the path
#
_loadLibTableFn () {
  declare _lib_table _lib_list _lib_line _raw_path _lib_file _is_loaded;
  _lib_table=("$@");

  ## Begin: Iterate over lib lines
  for _lib_line in "${_lib_table[@]}"; do
    # Split line into alternates
    #   Note: Echo removes trailing newline
    readarray -d: -t _lib_list < <(echo -n "${_lib_line}");
    _is_loaded='n';

    ## Begin: Iterate over alternates
    for _raw_path in "${_lib_list[@]}"; do
      [ -z "$(dirname "${_raw_path}")" ] \
        && _lib_file="${_binDir}/${_raw_path}" \
        || _lib_file="${_raw_path}";

      # shellcheck disable=SC1090
      if ! [ -r "${_lib_file}" ]; then
        _stderrFn "warn: source |${_lib_file}| not readable.";
      elif source "${_lib_file}"; then
        _is_loaded='y';
        break;
      else
        _stderrFn "${_baseName} Error: source |${_lib_file}| is non-zero.";
        return 1;
      fi
    done
    ## . End: Iterate over alternates

    if [ "${_is_loaded}" != 'y' ]; then
      _stderrFn "${_baseName} error: no lib loaded";
      return 1;
    fi
  done
  ## . End: Iterate over lib lines

  return;
}
## . END _loadLibTableFn }

## BEGIN Define error and exit handling {
_trapExitFn () {
  1>&2 echo "${_baseName} was interrupted";
  if [ "${_isPreparingSystem}" = 'y' ]; then
    _promptAllUsersFn 'error' "${_prepareFailMsg}";
  fi
  # If the lock file is deleted after a parallel kfocus-rollback-backend
  # process opens it, but before it locks it, this will cause two parallel
  # kfocus-rollback-backend processes to be able to execute, which is very
  # bad.
  # rm "${_lockFile}" || true;
}

_chkSetFlockFn () {
  mkdir -p "${_lockDir}";
  if ! [ -e "${_lockFile}" ]; then
    install -m 666 /dev/null "${_lockFile}";
  fi
  exec 211>"${_lockFile}" || {
    echo 'Lock file permission denied';
    return 21;
  };
  if ! flock -n -e 211; then
    1>&2 echo "Cannot get lock on ${_lockFile}";
    return 20;
  fi
  # Trap unexpected exits to show warnings if needed
  trap _trapExitFn EXIT;
}

_exitCleanFn () {
  declare _int;
  _int="$(_cm2EchoIntFn "${1:-0}")";
  trap '' EXIT;
  # If the lock file is deleted after a parallel kfocus-rollback-backend
  # process opens it, but before it locks it, this will cause two parallel
  # kfocus-rollback-backend processes to be able to execute, which is very
  # bad.
  # rm "${_lockFile}" || true;
  exit "${_int}";
}

_exitWithCodeFn () {
  declare _int _msg;

  _int="$(_cm2EchoIntFn "${1:-0}")";
  _msg="${2:-}";

  if [ -n "${_msg}" ]; then
    1>&2 echo "${_msg}";
    case ${_int} in
      '0') _cm2LogFn 'notice' "${_msg}";;
      '1') _cm2LogFn 'err'    "${_msg}";;
      '2') _cm2LogFn 'crit'   "${_msg}";;
      '3') _cm2LogFn 'alert'  "${_msg}";;
      '4') _cm2LogFn 'emerg'  "${_msg}";;
    esac
  fi
  _exitCleanFn "${_int}";
}

## TODO 2024-05-26 arraybolt3 WARN: Replace these.
_exitNOTICE () { _exitWithCodeFn  "${_rb2NOTICE}" "$@"; }
_exitERR ()    { _exitWithCodeFn  "${_rb2ERR}"    "$@"; }
_exitCRIT ()   { _exitWithCodeFn  "${_rb2CRIT}"   "$@"; }
_exitALERT ()  { _exitWithCodeFn  "${_rb2ALERT}"  "$@"; }
_exitEMERG ()  { _exitWithCodeFn  "${_rb2EMERG}"  "$@"; }
## . END Define error and exit handling }

## BEGIN _promptAllUsersFn {
# See https://stackoverflow.com/a/49533938
_promptAllUsersFn () {
  declare _mode _msg _xserver_id _user_name;
  _mode="${1:-info}";
  _msg="${2:-blank}";

  # Get all running X servers
  while read -r _xserver_id; do
    # Determine username of one graphically logged-in user
    _user_name="$(
      who | grep "(:${_xserver_id})" | head -n1 | awk '{ print $1 }'
    )";
    if [ -z "${_user_name}" ]; then continue; fi

    # Switch to the user and send a D-Bus message to their corresponding
    # kfocus-focusrx-dbus-dispatch process
    sudo -u "${_user_name}" \
      DISPLAY="${_xserver_id}" \
      DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$(id -u "${_user_name}")/bus" \
      qdbus org.kfocus.FocusRxDispatch.launcher / "${_mode}" "${_msg}";
  done < <(_cm2LsFn '/tmp/.X11-unix/' | sed 's?X??')
}
## . END _promptAllUsersFn }

## BEGIN _checkRootFn {
_checkRootFn () {
  declare _uid;
  _uid="$(id -u)";
  if [ "${_uid}" = '0' ]; then
    return 0;
  else
    return 1;
  fi
}
## . END _checkRootFn }

## BEGIN _clearRestoreFn {
_clearRestoreFn () {
  _checkBtrfsStatusSetUpFn;
  # TODO: Through a serious error here if cannot remove
  rm -f "${_rb2RestoreCompleteFile}" || true;
  _cm2LogFn 'notice' 'Restore flag cleared.';
}
## . END _clearRestoreFn }

## BEGIN _readMetadbFn {
_readMetadbFn () {
  # We intentionally do not check the BTRFS state here as _checkBtrfsStatusFn
  # has to read the metadb.
  declare _group_str _key_str;

  _group_str="${1:-}";
  _key_str="${2:-}";
  [ -n "${_group_str}" ] || {
    _cm2WarnStrFn 'No group string provided!';
    return 1;
  }
  [ -n "${_key_str}" ] || {
    _cm2WarnStrFn 'No key string provided!';
    return 1;
  }

  if ! [ -d '/btrfs_main' ]; then
    # The system may be legitimately unsupported, so we don't print an error
    # here.
    return 1;
  fi

  if [ -f "${_snapshotMetaDb}" ]; then
    "${_kreadconfig5Exe}" \
      --file "${_snapshotMetaDb}" \
      --group "${_group_str}" \
      --key "${_key_str}" \
      || _exitALERT 'Failed to read metadb!';
  elif [ -e "${_snapshotMetaDb}" ]; then
    _cm2WarnStrFn 'Snapshot metadb is not a regular file!';
    return 1;
  else
    touch "${_snapshotMetaDb}";
    chmod '0644' "${_snapshotMetaDb}";
    echo '';
  fi
}
## . END _readMetadbFn }

## BEGIN _writeMetadbFn {
_writeMetadbFn () {
  declare _group_str _key_str _val_str;

  _group_str="${1:-}";
  _key_str="${2:-}";
  _val_str="${3:-}";
  [ -n "${_group_str}" ] || {
    _cm2WarnStrFn 'No group string provided!';
    return 1;
  }
  [ -n "${_key_str}" ] || {
    _cm2WarnStrFn 'No key string provided!';
    return 1;
  }

  if ! [ -d '/btrfs_main' ]; then
    # The system may be legitimately unsupported, so we don't print an error
    # here.
    return 1;
  fi

  if ! [ -e "${_snapshotMetaDb}" ]; then
    touch "${_snapshotMetaDb}";
    chmod '0644' "${_snapshotMetaDb}";
  elif ! [ -f "${_snapshotMetaDb}" ] ; then
    _cm2WarnStrFn 'Snapshot metadb is not a regular file!';
    return 1;
  fi

  if [ -z "${_val_str}" ]; then
    "${_kwriteconfig5Exe}" \
      --file "${_snapshotMetaDb}" \
      --group "${_group_str}" \
      --key "${_key_str}" --delete \
      || _exitALERT 'Failed to delete metadb key!';
  else
    "${_kwriteconfig5Exe}" \
      --file "${_snapshotMetaDb}" \
      --group "${_group_str}" \
      --key "${_key_str}" \
      "${_val_str}" \
      || _exitALERT 'Failed to write metadb key!';
  fi
}
## . END _writeMetadbFn }

## BEGIN _getManualSwitchStateBackendFn {
# Purpose: Reads the manual switch state from the snapshot metadb. This is
# only used internally. It is split from _getManualSwitchStateFn because
# _checkBtrfsStatusFn needs to get the manual switch state, but external calls
# to this function need to call _checkBtrfsStatusSetUpFn, which will not
# return accurate results at that point.
#
_getManualSwitchStateBackendFn () {
  declare _manual_state_str;

  _manual_state_str="$(_readMetadbFn 'global' 'manualSwitchState')";

  if [ -z "${_manual_state_str}" ]; then
    _manual_state_str='MANUAL';
  fi

  if [ "${_manual_state_str}" != 'MANUAL' ] \
    && [ "${_manual_state_str}" != 'AUTO' ]; then
    _exitERR 'Manual switch state is not auto or manual!';
  fi

  echo "${_manual_state_str}";
}
## . END _getManualSwitchStateBackendFn }

## BEGIN _getManualSwitchStateFn {
# Purpose: Wraps _getManualSwitchStateBackendFn for external use by adding a
# BTRFS status check to it.
_getManualSwitchStateFn () {
  _checkBtrfsStatusSetUpFn;
  _getManualSwitchStateBackendFn;
}
## . END _getManualSwitchStateFn }

## BEGIN _setManualSwitchStateFn {
_setManualSwitchStateFn () {
  declare _state_str _current_state_str;

  _checkBtrfsStatusSetUpFn;
  _checkRootFn;

  # Get new and current switch states
  _state_str="${1:-}";
  if [ -z "${_state_str}" ]; then
    _exitERR 'Empty state string provided.';
  fi
  _current_state_str="$(_getManualSwitchStateBackendFn)";

  case "${_state_str}" in
    'auto')
      # Prohibit changing state to already existing state
      if [ "${_current_state_str}" = 'AUTO' ]; then
        _exitERR 'Cannot change manual switch state to existing state!';
      else
        # Write new state to db
        _writeMetadbFn 'global' 'manualSwitchState' 'AUTO';
      fi
      ;;
    'manual')
      # Prohibit changing state to already existing state
      if [ "${_current_state_str}" = 'MANUAL' ]; then
        _exitERR 'Cannot change manual switch state to existing state!';
      else
        # Write new state to db
        _writeMetadbFn 'global' 'manualSwitchState' 'MANUAL';
      fi
      ;;
    *)
      _exitERR 'Invalid state string provided.';
      ;;
  esac
}
## . END _setManualSwitchStateFn }

## BEGIN BTRFS maintenance helper functions {
_getMainUsageReportFn () {
  _checkBtrfsStatusSetUpFn;
  LC_ALL='C' "${_btrfsExe}" filesystem usage -b '/btrfs_main';
}

_getBootUsageReportFn () {
  _checkBtrfsStatusSetUpFn;
  LC_ALL='C' "${_btrfsExe}" filesystem usage -b '/btrfs_boot';
}

_getMainBtduReportFn () {
  _checkBtrfsStatusSetUpFn;
  LC_ALL='C' "${_btduExe}" --du --min-resolution=1M --headless '/btrfs_main'
}

_getMainFragReportFn () {
  _checkBtrfsStatusSetUpFn;
  "${_filefragExe}" '/btrfs_main/@';
}
## . END BTRFS maintenance helper functions }

## BEGIN _checkBtrfsStatusFn {
_checkBtrfsStatusFn () {
  declare _main_fs _boot_fs _main_subvols_str _boot_subvols_str;

  # The presence of /var/lib/portables or /var/lib/machines subvolumes will
  # interfere with snapshotting. These subvolumes may be created automatically
  # by systemd if it is not configured otherwise.
  if grep -q 'var/lib/portables' < <("${_btrfsExe}" subvolume list /) || \
     grep -q 'var/lib/machines' < <("${_btrfsExe}" subvolume list /); then
    if [ -n "$(ls -A /var/lib/portables)" ] || \
       [ -n "$(ls -A /var/lib/machines )" ]; then
      _btrfsStatus='UNSUPPORTED';
      return;
    fi
  fi

  if [ -d '/btrfs_main' ] && [ -d '/btrfs_boot' ]; then
    if [ -d '/btrfs_main/@' ] \
      && [ -d "${_rb2MainSnapshotDir}" ] \
      && [ -d '/btrfs_boot/@boot' ] \
      && [ -d "${_rb2BootSnapshotDir}" ]; then
      _main_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on / ' \
        | cut -d' ' -f1)";
      _boot_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on /boot ' \
        | cut -d' ' -f1)";
      if [ -n "${_main_fs}" ] && [ -n "${_boot_fs}" ] \
        && [ "${_main_fs}" != "${_boot_fs}" ]; then
        if [ "$(_getManualSwitchStateBackendFn)" = 'MANUAL' ]; then
          _btrfsStatus='SUPPORTED, MANUAL';
        else
          _btrfsStatus='SUPPORTED, AUTO';
        fi
      else
        _btrfsStatus='UNSUPPORTED';
      fi
    else
      _btrfsStatus='UNSUPPORTED';
    fi
  else
    if ! [ -d '/btrfs_main' ] && ! [ -d '/btrfs_boot' ]; then
      _main_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on / ' \
        | cut -d' ' -f1)";
      _boot_fs="$(LC_ALL='C' mount | grep btrfs | grep ' on /boot ' \
        | cut -d' ' -f1)";
      if [ -n "${_main_fs}" ] && [ -n "${_boot_fs}" ] \
        && [ "${_main_fs}" != "${_boot_fs}" ]; then
        _main_subvols_str="$("${_btrfsExe}" subvolume list / | awk '{ print $9 }' | sort)";
        _boot_subvols_str="$("${_btrfsExe}" subvolume list /boot | awk '{ print $9 }' | sort)";
        if grep -qE '^@$' <<< "${_main_subvols_str}" && \
          LC_ALL='C' mount | grep -q ' on /home '; then
          if [ -z "${_boot_subvols_str}" ]; then
            if ! grep -qE '^@kfocus-rollback-snapshots$' \
              <<< "${_main_subvols_str}"; then
              _btrfsStatus='SUPPORTED, NOT SET UP';
            else
              _btrfsStatus='INCONSISTENT';
            fi
          else
            _btrfsStatus='UNSUPPORTED';
          fi
        else
          _btrfsStatus='UNSUPPORTED';
        fi
      else
        _btrfsStatus='UNSUPPORTED';
      fi
    else
      _btrfsStatus='INCONSISTENT';
    fi
  fi
}
## . END _checkBtrfsStatusFn }

## BEGIN _checkBtrfsStatusSetUpFn {
_checkBtrfsStatusSetUpFn () {
  if [ "${_btrfsStatus}" != 'SUPPORTED, AUTO' ] \
    && [ "${_btrfsStatus}" != 'SUPPORTED, MANUAL' ]; then
    _exitNOTICE "${_btrfsStatus}";
  fi
}
## . END _checkBtrfsStatusSetUpFn }

## BEGIN Space checking functions {
_getMainUnallocSpaceFn () {
  _checkBtrfsStatusSetUpFn;

  # Extract unallocated space from main filesystem report
  LC_ALL=C "${_btrfsExe}" filesystem usage -b /btrfs_main \
    | awk '/Device unallocated/{ print $3 }';
}
_getMainMinUnallocFn () {
  _checkBtrfsStatusSetUpFn;

  # Calculate main filesystem size, return 15% of that
  echo "$(( $(LC_ALL=C "${_btrfsExe}" filesystem usage -b /btrfs_main \
    | grep $'Device size:\t' \
    | awk '{ print $3 }' \
    ) * 15 / 100 ))";
}
_getBootUnallocSpaceFn () {
  _checkBtrfsStatusSetUpFn;

  # Extract unallocated space from boot filesystem report
  LC_ALL=C "${_btrfsExe}" filesystem usage -b /btrfs_boot \
    | awk '/Device unallocated/{ print $3 }';
}
_getBootMinUnallocFn () {
  _checkBtrfsStatusSetUpFn;

  # Return number of bytes in 1 GiB
  echo 1073741824;
}
_checkMainUnallocSpaceFn () {
  declare _main_min_unalloc _main_unalloc;

  _checkBtrfsStatusSetUpFn;

  _main_min_unalloc="$(_getMainMinUnallocFn)";
  _main_unalloc="$(_getMainUnallocSpaceFn)";

  # Warn all users if main unallocated space is below minimum
  if (( _main_unalloc < _main_min_unalloc )); then
    _promptAllUsersFn 'rollbackLowMainSpace' "${_lowDiskMsg}";
    _exitERR 'Low disk space detected.';
  fi
}
_checkBootUnallocSpaceFn () {
  declare _boot_min_unalloc _boot_unalloc;

  _checkBtrfsStatusSetUpFn;

  _boot_min_unalloc="$(_getBootMinUnallocFn)";
  _boot_unalloc="$(_getBootUnallocSpaceFn)";

  # Warn all users if boot unallocated space is below minimum
  if (( _boot_unalloc < _boot_min_unalloc )); then
    _promptAllUsersFn 'rollbackLowBootSpace' "${_lowBootMsg}";
    _exitERR 'Low boot space detected.';
  fi
}
## . END Space checking functions }

## BEGIN _getSnapshotListStrFn {
_getSnapshotListStrFn () {
  _checkBtrfsStatusSetUpFn;

  # Return list of snapshots, sorted from newest to oldest
  _cm2LsFn "${_rb2MainSnapshotDir}" \
    | sed 's/@//' \
    | sort -nr \
    | sed 's/^/@/';
}
## . END _getSnapshotListStrFn }

## BEGIN _prepareSystemFn () {
_prepareSystemFn () {
  declare _root_mount_id _boot_mount_id _btrfs_defaults_str \
    _dir _subvolume_list _subvolume_id;

  _isPreparingSystem='y';

  ## Begin STAGE 1: Check and prep filesystem {
  if [ "${_btrfsStatus}" = 'SUPPORTED, AUTO' ] \
    || [ "${_btrfsStatus}" = 'SUPPORTED, MANUAL' ]; then
    _exitNOTICE 'This system already appears snapshot-enabled.';
  fi

  if [ "${_btrfsStatus}" = 'UNSUPPORTED' ]; then
    _exitERR 'This system does not support snapshotting.';
  fi

  # Check libvirt dirs, if they have content do not proceed
  if [ -d '/etc/libvirt' ] || [ -d '/var/lib/libvirt' ]; then
    if [ -n "$(ls -A /etc/libvirt     2>/dev/null)" ] || \
       [ -n "$(ls -A /var/lib/libvirt 2>/dev/null)" ]; then
      _exitERR 'Cannot create libvirt subvols, libvirt is installed!';
    fi
  fi

  # systemd may create /var/lib/portables and /var/lib/machines BTRFS
  # subvolumes of its own accord if not configured otherwise. Ensure that
  # these are not present.
  "${_btrfsExe}" subvolume delete --commit-after '/var/lib/portables' || true;
  "${_btrfsExe}" subvolume delete --commit-after '/var/lib/machines'  || true;

  # Create directories
  for _dir in '/btrfs_boot' '/btrfs_main' '/etc/libvirt' '/var/lib/libvirt'; do
    mkdir -p "${_dir}" || _exitCRIT "Cannot create ${_dir}";
  done;
  ## . End STAGE 1: Check and prep filesystem }

  ## Begin STAGE 2: Adjust fstab {
  _root_mount_id="$(LC_ALL=C mount | grep ' on / ' | cut -d' ' -f1)";
  _root_mount_id="UUID=$(LC_ALL=C lsblk -o NAME,FSTYPE,UUID,MOUNTPOINTS \
    "${_root_mount_id}" | sed -n '2p' | awk '{ print $3 }')";
  _boot_mount_id="UUID=$(LC_ALL=C lsblk -o NAME,FSTYPE,UUID,MOUNTPOINTS \
    | grep -P '/boot$' | awk '{ print $3 }')";
  _btrfs_defaults_str="defaults,noatime,autodefrag 0 0";

  echo "${_root_mount_id} /btrfs_main btrfs subvolid=5,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /btrfs_main';
  echo "${_boot_mount_id} /btrfs_boot btrfs subvolid=5,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /btrfs_boot';
  echo "${_root_mount_id} /etc/libvirt btrfs subvol=@libvirt-machines/@etc-libvirt,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /etc/libvirt';
  echo "${_root_mount_id} /var/lib/libvirt btrfs subvol=@libvirt-machines/@var-lib-libvirt,${_btrfs_defaults_str}" \
    >> /etc/fstab || _exitCRIT 'Cannot create fstab line for /var/lib/libvirt';
  ## . End STAGE 2: Adjust fstab }

  ## Begin STAGE 3: Prepare /boot {
  # Unmount boot-related directories, so we can rearrange their contents
  umount /boot/efi || _exitALERT 'Failed to unmount /boot/efi';
  umount /boot     || _exitALERT 'Failed to unmount /boot';

  # Point fstab at a soon-to-be-created @boot subvolume
  sed -i '/\/boot /s/defaults/subvol=\/@boot,defaults/' /etc/fstab \
    || _exitALERT 'Failed to update fstab for @boot';

  # Reload fstab changes
  systemctl daemon-reload;

  # Morph the layout of the boot partition
  mount /btrfs_boot || _exitALERT 'Failed to mount /btrfs_boot';
  "${_btrfsExe}" subvolume create /btrfs_boot/@boot \
    || _exitEMERG 'Failed to create @boot';

  # mv /btrfs_boot/* /btrfs_boot/@boot/ 2>/dev/null || true;
  while read -r _path; do
    if [ "${_path}" != '/btrfs_boot/@boot' ]; then
      mv "${_path}" '/btrfs_boot/@boot/' \
        || _exitALERT "Failed to move ${_path} to /btrfs_boot/@boot!";
    fi
  done < <(find '/btrfs_boot' -maxdepth 1 -mindepth 1)

  # Mount /boot again after successful rearrange
  mount /boot     || _exitALERT 'Failed to mount /boot';
  mount /boot/efi || _exitALERT 'Failed to mount /boot/efi';

  # Point the primary grub.cfg at the new boot files
  update-grub || _exitALERT 'Failed to update GRUB configuration';

  # Make sure GRUB can find the primary grub.cfg at its new location
  sed -i "s/'\/grub'/'\/@boot\/grub'/" /boot/efi/EFI/ubuntu/grub.cfg \
    || _exitALERT 'Failed to point GRUB to the proper config location';
  ## . End STAGE 3: Prepare /boot }

  ## Begin STAGE 4: Create subvolumes {
  # /btrfs_boot is already mounted at this point
  mount /btrfs_main || _exitALERT 'Failed to mount /btrfs_main';
  _subvolume_list=(
    "${_rb2BootSnapshotDir}"
    "${_rb2MainSnapshotDir}"
    '/btrfs_main/@libvirt-machines'
    '/btrfs_main/@libvirt-machines/@etc-libvirt'
    '/btrfs_main/@libvirt-machines/@var-lib-libvirt'
  );

  for _subvolume_id in "${_subvolume_list[@]}"; do
    "${_btrfsExe}" subvolume create "${_subvolume_id}" \
      || _exitEMERG "Failed to create ${_subvolume_id}";
  done
  ## . END Stage 4: Create subvolumes }

  ## Begin STAGE 5: Finish additional mounts {
  # At this point, /boot, /boot/efi, /btrfs_main, and /btrfs_boot are mounted.
  # /etc/libvirt and /var/lib/libvirt are not mounted.
  mount /etc/libvirt     || _exitALERT 'Failed to mount /etc/libvirt';
  mount /var/lib/libvirt || _exitALERT 'Failed to mount /var/lib/libvirt';
  ## . END STAGE 5: Finish additional mounts }

  _isPreparingSystem='n';
  _cm2LogFn 'notice' 'System successfully prepared for snapshotting.';
}
## . END _prepareSystemFn }

## BEGIN _deleteSnapshotFn {
_deleteSnapshotFn () {
  declare _target_snapshot_id _snapshot_dir _boot_snapshot_dir;

  # Ensure target snapshot exists
  _target_snapshot_id="${1:-}";
  if [ -z "${_target_snapshot_id}" ]; then
    _exitERR 'No snapshot name provided to delete!';
  fi

  _checkBtrfsStatusSetUpFn;

  # This intentionally does not have the @ before ${_target_snapshot_id} because
  # the function is passed a snapshot name, not just a timestamp.
  _snapshot_dir="${_rb2MainSnapshotDir}/${_target_snapshot_id}";
  _boot_snapshot_dir="${_rb2BootSnapshotDir}/${_target_snapshot_id}";

  # Ensure that either the main or boot or both BTRFS snapshots are present
  if ! [ -e "${_snapshot_dir}" ] && ! [ -e "${_boot_snapshot_dir}" ]; then
    _exitERR 'Snapshot deletion request points to a non-existent snapshot!';
  fi

  # Refuse deleting a pinned snapshot
  if [ "$(_readMetadbFn "${_target_snapshot_id}" 'pinned')" = 'y' ]; then
    _exitERR 'Cannot delete a pinned snapshot!';
  fi

  # Delete both BTRFS snapshots, taking into account there may only be one
  if [ -e "${_snapshot_dir}" ]; then
    "${_btrfsExe}" subvolume delete --commit-after "${_snapshot_dir}" \
      || _exitEMERG "Failed to delete main BTRFS snapshot ${_snapshot_dir}!";
  fi
  if [ -e "${_boot_snapshot_dir}" ]; then
    "${_btrfsExe}" subvolume delete --commit-after "${_boot_snapshot_dir}" \
      || _exitEMERG "Failed to delete boot BTRFS snapshot ${_boot_snapshot_dir}!";
  fi

  # Ensure any and all snapshot metadata is deleted
  _writeMetadbFn "${_target_snapshot_id}" 'name' '';
  _writeMetadbFn "${_target_snapshot_id}" 'desc' '';
  _writeMetadbFn "${_target_snapshot_id}" 'pinned' '';
  
  _cm2LogFn 'notice' "Snapshot ${_target_snapshot_id} deleted.";
}
## . END _deleteSnapshotFn }

## BEGIN _finalizeRestoreFn {
_finalizeRestoreFn () {
  _checkBtrfsStatusSetUpFn;

  # Ensure system is not in post-restore pre-reboot state
  if ! mount | grep 'btrfs' | grep -q '@kfocus-rollback-working' \
    && ! mount | grep 'btrfs' | grep -q '@kfocus-rollback-working-boot'; then

    # Delete obsolete main working subvol made during restore
    if [ -d "${_rb2MainWorkingDir}" ]; then
      "${_btrfsExe}" subvolume delete \
        --commit-after "${_rb2MainWorkingDir}" \
        || _exitEMERG 'Failed to finalize restore for main filesystem!';
    fi

    # Delete obsolete boot working subvol made during restore
    if [ -d "${_rb2BootWorkingDir}" ]; then
      "${_btrfsExe}" subvolume delete \
        --commit-after "${_rb2BootWorkingDir}" \
        || _exitEMERG 'Failed to finalize restore for boot filesystem!';
    fi
  else
    _exitERR 'Cannot finalize restore, restore operation half-done!';
  fi
  _cm2LogFn 'notice' 'Restore operation successfully finalized.';
}
## . END _finalizeRestoreFn }

## BEGIN _trimSnapshotsFn {
_trimSnapshotsFn () {
  declare _main_snapshot_list _boot_snapshot_list _snapshot_id \
    _snapshot_remove_count _snapshot_idx _delete_count _main_list_count;

  _checkBtrfsStatusSetUpFn;

  _delete_count=0;

  # Get main and boot snapshot lists
  readarray -t _main_snapshot_list <<< "$(
    _cm2LsFn "${_rb2MainSnapshotDir}" | sed 's/@//' | sort -n | sed 's/^/@/'
  )";
  readarray -t _boot_snapshot_list <<< "$(
    _cm2LsFn "${_rb2BootSnapshotDir}" | sed 's/@//' | sort -n | sed 's/^/@/'
  )";

  # Remove main snapshots with no corresponding boot snapshots
  for _snapshot_id in "${_main_snapshot_list[@]}"; do
    if ! [[ " ${_boot_snapshot_list[*]} " \
      =~ [[:space:]]${_snapshot_id}[[:space:]] ]]; then
      _deleteSnapshotFn "${_snapshot_id}";
      _cm2LogFn 'warning' \
        "Mismatched BTRFS snapshot ${_snapshot_id} trimmed from main.";
    fi
  done

  # Remove boot snapshots with no corresponding main snapshots
  for _snapshot_id in "${_boot_snapshot_list[@]}"; do
    if ! [[ " ${_main_snapshot_list[*]} " \
      =~ [[:space:]]${_snapshot_id}[[:space:]] ]]; then
      _deleteSnapshotFn "${_snapshot_id}";
      _cm2LogFn 'warning' \
        "Mismatched BTRFS snapshot ${_snapshot_id} trimmed from boot.";
    fi
  done

  # Re-read list of main snapshots
  readarray -t _main_snapshot_list <<< "$(
    _cm2LsFn "${_rb2MainSnapshotDir}" | sed 's/@//' | sort -n | sed 's/^/@/'
  )";

  # Exclude pinned snapshots, avoid unset shrinkage bug
  _main_list_count="${#_main_snapshot_list[@]}";
  for ((_snapshot_idx = 0; _snapshot_idx < _main_list_count; \
    _snapshot_idx++)); do
    if [ "$(_readMetadbFn "${_main_snapshot_list[_snapshot_idx]}" \
      'pinned')" = 'y' ]; then
      unset "_main_snapshot_list[_snapshot_idx]";
    fi
  done

  # Remove holes left by unset
  _main_snapshot_list=( "${_main_snapshot_list[@]}" );

  # Trim unpinned snapshots down to no more than 5
  if [ "${#_main_snapshot_list[@]}" -gt '5' ]; then
    _snapshot_remove_count=$((${#_main_snapshot_list[@]} - 5));
    for ((_snapshot_idx = 0; _snapshot_idx < _snapshot_remove_count; \
      _snapshot_idx++)); do
      _deleteSnapshotFn "${_main_snapshot_list[_snapshot_idx]}";
      (( _delete_count++ )) || true;
    done
  fi

  _cm2LogFn 'notice' \
    "Snapshots trimmed, deleting ${_delete_count} non-mismatched snapshots.";
}
## . END _trimSnapshotsFn }

## BEGIN _createSnapshotFn {
_createSnapshotFn () {
  declare _snapshot_event_type _timestamp_str _prev_timestamp_str \
    _snapshot_path _boot_snapshot_path _hour_seconds _week_seconds;

  _checkBtrfsStatusSetUpFn;
  _checkMainUnallocSpaceFn;
  _checkBootUnallocSpaceFn;

  _hour_seconds=3600;
  _week_seconds=604800;

  # If a pre-existing snapshot ID is generated, sleep one second and retry
  while true; do
    _timestamp_str="$(date +%s)";
    _snapshot_path="${_rb2MainSnapshotDir}/@${_timestamp_str}";
    _boot_snapshot_path="${_rb2BootSnapshotDir}/@${_timestamp_str}";

    if [ -e "${_snapshot_path}" ] || [ -e "${_boot_snapshot_path}" ]; then
      sleep 1;
      continue;
    fi
    break;
  done

  # Get timestamp of most recent existing snapshot
  _prev_timestamp_str="$(
    _cm2LsFn "${_rb2MainSnapshotDir}" \
      | sed 's/@//' | sort -n | tail -n1
  )";
  _snapshot_event_type="${1:-}"

  # Disallow automatic snapshots when insufficient time has passed, OEM
  # configuration mode is active, or automatic snapshots are turned off
  case "${_snapshot_event_type}" in
    'Apt')
      if (( ( _timestamp_str - _prev_timestamp_str ) < _hour_seconds )); then
        _exitNOTICE 'Too little time has elapsed for another snapshot';
      fi
      if [ -d '/oem' ]; then
        _exitNOTICE 'Cannot create apt snapshot in OEM configuration mode';
      fi
      if [ "${_btrfsStatus}" = 'SUPPORTED, MANUAL' ]; then
        _exitNOTICE 'Cannot create apt snapshot in manual snapshot mode';
      fi
      ;;
    'Timed')
      if (( ( _timestamp_str - _prev_timestamp_str ) < _week_seconds )); then
        _exitNOTICE 'Too little time has elapsed for another snapshot';
      fi
      if [ -d '/oem' ]; then
        _exitNOTICE 'Cannot create timed snapshot in OEM configuration mode';
      fi
      if [ "${_btrfsStatus}" = 'SUPPORTED, MANUAL' ]; then
        _exitNOTICE 'Cannot create timed snapshot in manual snapshot mode';
      fi
      ;;
  esac

  # Save snapshot creation reason in the metadata database
  _writeMetadbFn "@${_timestamp_str}" 'reason' "${_snapshot_event_type}";

  # Snapshot and sync main and boot filesystems
  "${_btrfsExe}" subvolume snapshot -r '/btrfs_main/@' "${_snapshot_path}" \
    || _exitEMERG "Could not create snapshot |${_snapshot_path}|";
  "${_btrfsExe}" filesystem sync '/btrfs_main' \
    || _exitEMERG 'Failed to sync main filesystem!';
  "${_btrfsExe}" subvolume snapshot -r '/btrfs_boot/@boot' "${_boot_snapshot_path}" \
    || _exitEMERG "Could not create boot snapshot |${_boot_snapshot_path}|";
  "${_btrfsExe}" filesystem sync '/btrfs_boot' \
    || _exitEMERG 'Failed to sync boot filesystem!';
  sync;

  _cm2LogFn 'notice' "Snapshot @${_timestamp_str} created.";
}
## . END _createSnapshotFn

## BEGIN _compareSnapshotsFn {
_compareStateFn () {
  declare _source_state_dir _target_state_dir;

  _checkBtrfsStatusSetUpFn;
  _checkRootFn || _exitNOTICE 'State comparison requires root privileges.';

  # Ensure source and target dirs actually exist
  _source_state_dir="${1:-}";
  [ -z "${_source_state_dir}" ] \
    && _exitERR 'No source state dir provided to comparer!';
  ! [ -d "${_source_state_dir}" ] \
    && _exitERR 'Specified source state dir does not exist or is not a dir!';
  _target_state_dir="${2:-}";
  [ -z "${_target_state_dir}" ] \
    && _exitERR 'No target state dir provided to comparer!';
  ! [ -d "${_target_state_dir}" ] \
    && _exitERR 'Specified target state dir does not exist or is not a dir!';

  # Diff directories, return filenames only
  "${_diffExe}" -r --brief "${_source_state_dir}" "${_target_state_dir}";
}
## . END _compareSnapshotsFn }

## BEGIN _getSnapshotReasonFn {
# Purpose: Reads the snapshot reason string from a snapshot, converts it to a
# human-readable form, and returns it.
#
_getSnapshotReasonFn () {
  declare _snapshot_id _snapshot_reason_file _snapshot_reason_raw \
    _snapshot_reason;

  _snapshot_id="${1:-}";
  _snapshot_reason_file="${_rb2MainSnapshotDir}/${_snapshot_id}";
  _snapshot_reason_file+='/var/lib/kfocus/rollback_snapshot_reason';

  if [ -z "${_snapshot_id}" ]; then
    _cm2WarnStrFn 'Invalid argument, cannot get snapshot reason';
    return 1;
  fi

  _snapshot_reason_raw="$(_readMetadbFn "${_snapshot_id}" 'reason')";

  # Migrate reason to metadb if stored old-style inside the snapshot
  if [ -z "${_snapshot_reason_raw}" ]; then
    _snapshot_reason_raw="$(cat "${_snapshot_reason_file}")";
    _writeMetadbFn "${_snapshot_id}" 'reason' "${_snapshot_reason_raw}";
  fi

  case "${_snapshot_reason_raw}" in
    'Apt')
      _snapshot_reason='Before Package Change';
      ;;
    'Timed')
      _snapshot_reason='System Schedule';
      ;;
    'Pre-Rollback')
      _snapshot_reason='Pre-Rollback';
      ;;
    *) # must be user-generated
      _snapshot_reason="User Snapshot (${_snapshot_reason_raw})";
      ;;
  esac

  echo "${_snapshot_reason}";
}
## . END _getSnapshotReasonFn }

## BEGIN _makeSnapshotDispIdFn {
# Purpose: Gets snapshot date of creation and name, and combines them into a
# human-readable name.
#
_makeSnapshotDispIdFn () {
  declare _snapshot_id _snapshot_name _snapshot_datetime _snapshot_disp_id;

  _snapshot_id="${1:-}";

  if [ -z "${_snapshot_id}" ]; then
    _cm2WarnStrFn 'Invalid arguments, cannot generate snapshot display ID';
    return 1;
  fi

  _snapshot_name="$(_readMetadbFn "${_snapshot_id}" 'name')";
  if [ -z "${_snapshot_name}" ]; then
    _snapshot_name="$(_getSnapshotReasonFn "${_snapshot_id}")";
  else
    _snapshot_name="$(base64 -d <<< "${_snapshot_name}")";
  fi

  _snapshot_datetime="$(date -d "${_snapshot_id}" '+%a %F %H:%M')";
  _snapshot_disp_id="${_snapshot_name} — ${_snapshot_datetime}";
  echo "${_snapshot_disp_id}";
}
## . END _makeSnapshotDispIdFn }

## BEGIN _restoreSnapshotFn {
_restoreSnapshotFn () {
  declare _target_snapshot_id _snapshot_path \
    _boot_snapshot_path _snapshot_name _snapshot_date _snapshot_reason \
    _umount_cnt _efi_umount_yn;

  _checkBtrfsStatusSetUpFn;
  _checkMainUnallocSpaceFn;
  _checkBootUnallocSpaceFn;

  _target_snapshot_id="${1:-}";

  if [ -z "${_target_snapshot_id}" ]; then
    _exitERR 'No snapshot name provided to restore!';
  fi

  # Do not restore again if in post-restore, pre-reboot state
  if [ -e "${_rb2MainWorkingDir}" ] \
    || [ -e "${_rb2BootWorkingDir}" ]; then
    _cm2ErrStrFn 'Temporary restore subvols found, cannot continue.';
    _cm2ErrStrFn 'Please reboot, then run "Finish restoration operation".';
    _exitERR 'Restore already in progress!';
  fi
  
  _snapshot_path="${_rb2MainSnapshotDir}/${_target_snapshot_id}";
  _boot_snapshot_path="${_rb2BootSnapshotDir}/${_target_snapshot_id}";

  # Ensure both main and boot BTRFS snapshots exist
  if ! [ -e "${_snapshot_path}" ] || ! [ -e "${_boot_snapshot_path}" ]; then
    _exitERR "Part or all of the snapshot |${_target_snapshot_id}| does not exist!";
  fi

  # Failing to unmount /boot/efi before attempting to move the old subvol
  # will result in the subvol not being moved, which will result in the
  # whole @boot subvol being nuked except for the contents of /boot/efi.
  #
  # Unmount EFI System Partition
  _efi_umount_yn='n';
  for (( _umount_cnt=0; _umount_cnt < 3; _umount_cnt++)); do
    if ! umount /boot/efi ; then
      sleep 1;
    else
      _efi_umount_yn='y';
      break;
    fi
  done

  if [ "${_efi_umount_yn}" = 'n' ]; then
    _exitERR 'Unable to unmount EFI system partition!';
  fi

  # Create pre-rollback snapshot for safety
  _createSnapshotFn 'Pre-Rollback' || exit;

  # Retrieve relevant metadata from snapshot being restored
  _snapshot_name="$(_readMetadbFn "${_target_snapshot_id}" 'name')";
  _snapshot_date="${_target_snapshot_id//@/}";
  _snapshot_reason="$(_getSnapshotReasonFn "${_target_snapshot_id}")";

  # Move existing main and boot subvols, restore new ones
  mv '/btrfs_main/@' "${_rb2MainWorkingDir}" \
    || _exitCRIT 'Unable to move root filesystem subvolume for restore!';
  "${_btrfsExe}" subvolume snapshot "${_snapshot_path}" '/btrfs_main/@' \
    || _exitEMERG 'Unable to restore root filesystem snapshot!';
  "${_btrfsExe}" filesystem sync '/btrfs_main' \
    || _exitEMERG 'Unable to sync main filesystem!';
  mv '/btrfs_boot/@boot' '/btrfs_boot/@kfocus-rollback-working-boot' \
    || _exitALERT 'Unable to move boot filesystem subvolume for restore!';
  "${_btrfsExe}" subvolume snapshot "${_boot_snapshot_path}" '/btrfs_boot/@boot' \
    || _exitEMERG 'Unable to restore boot filesystem snapshot!';
  "${_btrfsExe}" filesystem sync '/btrfs_boot' \
    || _exitEMERG 'Unable to sync boot filesystem!';
  sync;

  # Remount EFI System Partition
  mount /boot/efi || _exitALERT 'Unable to remount EFI system partition!';

  # Save relevant snapshot metadata for post-reboot handler retrieval
  {
    echo "${_snapshot_name}";
    echo "${_snapshot_date}";
    echo "${_snapshot_reason}";
  } > "/btrfs_main/@${_rb2RestoreCompleteFile}" \
    || _exitALERT 'Unable to prepare system for post-snapshot cleanup!';
 
  # Trim older snapshots
  _trimSnapshotsFn || _exitALERT 'Unable to trim snapshots post-restore!';

  _cm2LogFn 'notice' "Snapshot ${_target_snapshot_id} restored.";
}
## . END _restoreSnapshotFn }

## BEGIN _systemSnapshotFn {
# Purpose: Wraps _createSnapshotFn with safety checks and post-creation
# trimming. Used when the end-user creates a snapshot.
#
_systemSnapshotFn () {
  _checkBtrfsStatusSetUpFn;
  _checkMainUnallocSpaceFn;
  _checkBootUnallocSpaceFn;
  _createSnapshotFn "${1:-}" || _exitERR 'Could not create snapshot!';
  _trimSnapshotsFn           || _exitERR 'Could not trim snapshots!';
}
## . END _systemSnapshotFn }

## BEGIN _getSnapshotMetadataFn {
_getSnapshotMetadataFn () {
  declare _snapshot_id _mode _item _space_report _metadata_str;
  
  _checkBtrfsStatusSetUpFn;

  _snapshot_id="${1:-}";
  _mode="${2:-}";
  [ -z "${_snapshot_id}" ] && _exitERR 'No snapshot ID provided!';
  [ "${_mode}" != 'base' ] && [ "${_mode}" != 'full' ] \
    && _exitERR 'No mode or invalid mode provided!';
  [ -d "${_rb2MainSnapshotDir}/${_snapshot_id}" ] \
    || _exitERR 'The specified snapshot does not exist!'

  # Return snapshot name, description, pin status from snapshot metadb
  for _item in 'name' 'desc' 'pinned'; do
    _metadata_str="$(_readMetadbFn "${_snapshot_id}" "${_item}")";
    if [ "${_item}" = 'pinned' ] && [ -z "${_metadata_str}" ]; then
      _cm2WarnStrFn "Missing metadata entry for snapshot ${_snapshot_id} in ${_snapshotMetaDb}";
    fi
    echo "${_metadata_str}";
  done

  # Return human-readable snapshot reason
  _getSnapshotReasonFn "${_snapshot_id}";

  # Calculate and return snapshot size if requested
  if [ "${_mode}" = 'full' ]; then
    "${_btrfsExe}" 'filesystem' 'du' '--raw' '-s' \
      "${_rb2MainSnapshotDir}/${_snapshot_id}" \
      | tail -n1 \
      | awk '{ print $2 }'
  else
    echo '';
  fi
}
## . END _getSnapshotMetadataFn }

## BEGIN _setSnapshotMetadataFn {
_setSnapshotMetadataFn () {
  declare _snapshot_id _name_str _desc_str _is_pinned _was_pinned;
  
  _checkBtrfsStatusSetUpFn;

  _snapshot_id="${1:-}";
  _name_str="${2:-}";
  _desc_str="${3:-}";
  _is_pinned="${4:-}";

  [ -z "${_snapshot_id}" ] && _exitERR 'No snapshot ID provided!';
  [ -z "${_is_pinned}" ] && _exitERR 'No pinning information provided!';
  [ -d "${_rb2MainSnapshotDir}/${_snapshot_id}" ] \
    || _exitERR 'The specified snapshot does not exist!'
  [[ "${_is_pinned}" =~ ^[yn]$ ]] || _exitERR 'Pinning data is not boolean!';

  # If pinning an unpinned snapshot, check disk space
  if [ "${_is_pinned}" = 'y' ]; then
    _was_pinned="$(_readMetadbFn "${_snapshot_id}" 'pinned')";
    if [ "${_was_pinned}" = 'n' ]; then
      _checkMainUnallocSpaceFn;
      _checkBootUnallocSpaceFn;
    fi
  fi

  # Write snapshot name, description, pin status to snapshot metadb
  _writeMetadbFn "${_snapshot_id}" 'name' "${_name_str}";
  _writeMetadbFn "${_snapshot_id}" 'desc' "${_desc_str}";
  _writeMetadbFn "${_snapshot_id}" 'pinned' "${_is_pinned}";
}
## . END _setSnapshotMetadataFn }

## BEGIN _balanceMainFn {
_balanceMainFn () {
  declare _do_force_balance _main_report _main_unalloc_int _main_free_int \
    _last_unalloc_int _last_free_int _trigger_threshold _balance_percent \
    _do_balance;
  
  _do_force_balance="${1:-n}";
  _do_balance='n';
  _checkBtrfsStatusSetUpFn;
  _trigger_threshold=5368709120; # 5 GiB

  # Extract unallocated and free space from main fs report
  _main_report="$(_getMainUsageReportFn)";
  _main_unalloc_int="$(grep $'Device unallocated:\t' <<< "${_main_report}" \
    | awk '{ print $3 }')";
  _main_free_int="$(grep $'Free (estimated):\t' <<< "${_main_report}" \
    | awk '{ print $3 }')";

  # Read previous space values from snapshot metadb
  _last_unalloc_int="$(_readMetadbFn 'global' 'lastUnallocInt')";
  _last_free_int="$(_readMetadbFn 'global' 'lastFreeInt')";
  if [ -z "${_last_unalloc_int}" ] \
    || [ -z "${_last_free_int}" ]; then
    _last_unalloc_int=-1;
    _last_free_int=0;
  fi

  # Always balance if forced, and balance more intensively
  if [ "${_do_force_balance}" = 'y' ]; then
    _balance_percent='85';
    _do_balance='y'
  # Else, balance if free space growth or unallocated space shrinkage exceeds
  # threshold
  elif (( (_last_unalloc_int - _main_unalloc_int) >= "${_trigger_threshold}" )) \
    || (( (_main_free_int - _last_free_int) >= "${_trigger_threshold}" )); then
    _balance_percent='70';
    _do_balance='y';
  fi

  # Balance if conditions met
  if [ "${_do_balance}" = 'y' ]; then
    # Balance main fs
    "${_btrfsBalanceExe}" -u "${_balance_percent}" '/btrfs_main';

    # Save new unallocated and free space data to state file
    _main_report="$(_getMainUsageReportFn)";
    _main_unalloc_int="$(grep $'Device unallocated:\t' <<< "${_main_report}" \
      | awk '{ print $3 }')";
    _main_free_int="$(grep $'Free (estimated):\t' <<< "${_main_report}" \
      | awk '{ print $3 }')";
    _writeMetadbFn 'global' 'lastUnallocInt' "${_main_unalloc_int}";
    _writeMetadbFn 'global' 'lastFreeInt' "${_main_free_int}";

    _cm2LogFn 'notice' "Main filesystem balanced.";
  else
    _cm2LogFn 'notice' \
      "Main filesystem not balanced: not forced and threshold not met.";
  fi
}
## . END _balanceMainFn }

## BEGIN _balanceBootFn {
_balanceBootFn () {
  _checkBtrfsStatusSetUpFn;

  # Unconditionally balance boot space
  "${_btrfsBalanceExe}" -u 85 '/btrfs_boot';

  _cm2LogFn 'notice' "Boot filesystem balanced.";
}
## . END _balanceBootFn }

## BEGIN _deleteAllSnapshotsFn {
_deleteAllSnapshotsFn () {
  declare _snapshot_list _current_snapshot;
  
  _checkBtrfsStatusSetUpFn;

  # Get list of snapshots
  readarray -t _snapshot_list < <(
    _cm2LsFn "${_rb2MainSnapshotDir}" 2>/dev/null
  );

  # Exit if no snapshots exist
  if [ "${#_snapshot_list[@]}" = '0' ] || [ -z "${_snapshot_list[0]}" ]; then
    _cm2WarnStrFn 'No snapshots found.';
    return;
  fi

  # Delete each snapshot, unpinning if needed
  for _current_snapshot in "${_snapshot_list[@]}"; do
    if [ "$(_readMetadbFn "${_current_snapshot}" 'pinned')" = 'y' ]; then
      _writeMetadbFn "${_current_snapshot}" 'pinned' 'n';
    fi
    _deleteSnapshotFn "${_current_snapshot}";
  done

  _cm2LogFn 'notice' "All snapshots deleted.";
}
## . END _deleteAllSnapshotsFn }

## BEGIN _defragmentFn {
_defragmentFn () {
  declare _frag_report _frag_count_list _target_frag_list _frag_file_list \
    _defrag_file_list _report_idx _btdu_report _btdu_val_list \
    _btdu_file_list _file_size _unreachable_size _clean_file_list \
    _defrag_list_idx _merge_yn _clean_list_idx _current_file;
  
  _checkBtrfsStatusSetUpFn;

  # Get report of file fragmentation on main filesystem, sorted by excessive
  # fragments
  _frag_report="$(
    _getMainFragReportFn \
    | sort -nr;
  )";

  # Split fragmentation report into frag count, ideal frag count, and files
  readarray -t _frag_count_list  < <(cut -d'|' -f2 <<< "${_frag_report}");
  readarray -t _target_frag_list < <(cut -d'|' -f3 <<< "${_frag_report}");
  readarray -t _frag_file_list   < <(cut -d'|' -f4 <<< "${_frag_report}");

  # Get list of all files with more fragments than ideal
  _defrag_file_list=();
  for (( _report_idx=0; _report_idx < ${#_frag_file_list[@]}; \
    _report_idx++ )); do
    _current_file="${_frag_file_list[_report_idx]}";

    if [ -f "${_current_file}" ]; then
      if (( _frag_count_list[_report_idx] > \
        _target_frag_list[_report_idx] )); then
        _defrag_file_list+=( "${_current_file}" );
      fi
    fi
  done

  # Trim list count to 50
  if (( ${#_defrag_file_list[@]} > 50 )); then
    _defrag_file_list=( "${_defrag_file_list[@]:0:50}" );
  fi

  # Get report of unreachable space, sorted by quantity
  _btdu_report="$(
    _getMainBtduReportFn \
      | grep '<UNREACHABLE>' \
      | sort -nr \
      | sed 's|/<SINGLE>/<DATA>/<UNREACHABLE>||; /<ERROR>/d'
  )";

  # Split report into unreachable space and files
  readarray -t _btdu_val_list < <(cut -f1 <<< "${_btdu_report}");
  readarray -t _btdu_file_list < <(cut -f2 <<< "${_btdu_report}");

  # Get list of all files with unreachable space greater than 15% of file size
  _clean_file_list=();
  for (( _report_idx=0; _report_idx < ${#_btdu_val_list[@]}; \
    _report_idx++ )); do
    _current_file="${_btdu_file_list[_report_idx]}";

    if [ -f "${_current_file}" ]; then
      _file_size="$(du -b "${_current_file}" | cut -f1)";
      (( _unreachable_size = _btdu_val_list[_report_idx] * 1024 ));

      if [ "$(bc -l <<< "scale=2; (${_unreachable_size} / ${_file_size}) > 0.15")" \
        = '1' ]; then
        _clean_file_list+=( "${_current_file}" );
      fi
    fi
  done

  # Trim list count to 50
  if (( ${#_clean_file_list[@]} > 50 )); then
    _clean_file_list=( "${_clean_file_list[@]:0:50}" );
  fi

  # Find all items in defrag list not in clean list, and add to clean list
  for (( _defrag_list_idx=0; _defrag_list_idx < "${#_defrag_file_list[@]}"; \
    _defrag_list_idx++ )); do
    _current_file="${_defrag_file_list[_defrag_list_idx]}";
    _merge_yn='y';
    for (( _clean_list_idx=0; _clean_list_idx < "${#_clean_file_list[@]}"; \
      _clean_list_idx++ )); do
      if [ "${_current_file}" = "${_clean_file_list[_clean_list_idx]}" ]; then
        _merge_yn='n';
        break;
      fi
    done

    if [ "${_merge_yn}" = 'y' ]; then
      _clean_file_list+=( "${_current_file}" );
    fi
  done

  # Defragment all files in clean list, use lzo compression
  if (( ${#_defrag_file_list[@]} > 0 )); then
    "${_btrfsExe}" filesystem defragment -clzo "${_clean_file_list[@]}";
  fi

  _cm2LogFn 'notice' \
    "Defragmented ${#_defrag_file_list[@]} files on main filesystem.";
}
## . END _defragmentFn }

## BEGIN _btrfsMaintainFn {
# Purpose: Runs both main and boot balance operations at once.
#
_btrfsMaintainFn () {
  _checkRootFn       || _exitNOTICE \
    'BTRFS maintenance requires root privileges.';
  _checkBtrfsStatusSetUpFn;
  _balanceMainFn 'n' || _exitALERT  'Failed to balance main filesystem!';
  _balanceBootFn     || _exitALERT  'Failed to balance boot filesystem!';
  _cm2LogFn 'notice' "Routine BTRFS maintenance complete.";
}
## . END _btrfsMaintainFn }

## BEGIN _btrfsDeepCleanFn {
# Purpoes: Runs snapshot wipe, forced main balance, boot balance, and
# defragment operations at once.
#
_btrfsDeepCleanFn () {
  _checkRootFn       || _exitNOTICE \
    'BTRFS deep cleaning requires root privileges.';
  _checkBtrfsStatusSetUpFn;
  _deleteAllSnapshotsFn;
  _balanceMainFn 'y' || _exitALERT 'Failed to balance main filesystem!';
  _balanceBootFn     || _exitALERT 'Failed to balance boot filesystem!';
  _defragmentFn      || _exitALERT 'Failed to defragment files!';
  _cm2LogFn 'notice' "BTRFS deep clean operation complete.";
}
## . END _btrfsDeepCleanFn }

## BEGIN _mainFn {
_mainFn () {
  declare _mode_str _arg2_str;
  _mode_str="${1:-}";
  shift;

  while ! _chkSetFlockFn; do
    sleep 1;
  done

  # TODO: Fix this, we should refuse to do almost anything if in INCONSISTENT
  # state but some of the functions of the script may need to work anyway.
  _checkBtrfsStatusFn;
  if [ "${_btrfsStatus}" = 'INCONSISTENT' ]; then
    _promptAllUsersFn 'warning' "${_inconsistentMsg}";
    _exitERR 'BTRFS state is inconsistent!';
  fi

  case "${_mode_str}" in
    'btrfsDeepClean')          _btrfsDeepCleanFn;;
    'btrfsMaintain')           _btrfsMaintainFn;;
    'checkBootUnallocSpace')   _checkBootUnallocSpaceFn;;
    'checkMainUnallocSpace')   _checkMainUnallocSpaceFn;;
    'clearRestore')            _clearRestoreFn;;
    'compareState')            _compareStateFn         "$@";;
    'createSnapshot')          _createSnapshotFn       "${1:-}";;
    'deleteSnapshot')          _deleteSnapshotFn       "${1:-}";;
    'finalizeRestore')         _finalizeRestoreFn;;
    'getBaseSnapshotMetadata') _getSnapshotMetadataFn  "${1:-}"   'base';;
    'getBootMinUnalloc')       _getBootMinUnallocFn;;
    'getBootUnallocSpace')     _getBootUnallocSpaceFn;;
    'getBtrfsStatus')          echo "${_btrfsStatus}";;
    'getFullSnapshotMetadata') _getSnapshotMetadataFn  "${1:-}"   'full';;
    'getMainMinUnalloc')       _getMainMinUnallocFn;;
    'getMainUnallocSpace')     _getMainUnallocSpaceFn;;
    'getManualSwitchState')    _getManualSwitchStateFn;;
    'getSnapshotList')         _getSnapshotListStrFn;;
    'getSnapshotReason')       _getSnapshotReasonFn    "${1:-}";;
    'makeSnapshotDispId')      _makeSnapshotDispIdFn   "${1:-}";;
    'prepareSystem')           _prepareSystemFn;;
    'restoreSnapshot')         _restoreSnapshotFn      "${1:-}";;
    'setManualSwitchState')    _setManualSwitchStateFn "${1:-}";;
    'setSnapshotMetadata')     _setSnapshotMetadataFn  "$@";;
    'systemSnapshot')          _systemSnapshotFn       "${1:-}";;
    'trimSnapshots')           _trimSnapshotsFn;;
    *)
      _exitERR 'Invalid mode specified.';
      ;;
  esac

  _exitCleanFn;
}
## . END _mainFn }

## BEGIN Declare and assign global vars {
declare _binName _binDir _baseName _baseDir \
  _isPreparingSystem _lockFile _btrfsStatus _snapshotMetaDb \
  _libTable _browStr _erowStr _tableStr _prepareFailMsg \
  _lowDiskMsg _lowBootMsg _inconsistentMsg _btrfsExe _btduExe _filefragExe \
  _btrfsBalanceExe _kwriteconfig5Exe _kreadconfig5Exe _diffExe;

_btrfsStatus='';
_isPreparingSystem='n'; # Flag for error reporting

# WARNING: Do NOT change the name of the lock file no matter what the name of
# this script changes to. If kfocus-rollback-set from Rollback v1 is running
# when Rollback v2 is installed, and then kfocus-rollback-backend from
# Rollback v2 is launched before the v1 process terminates, they will run
# simultaneously and potentially cause data loss.
_lockFile='/tmp/kfocus-rollback/kfocus-rollback-set.lock';
_lockDir='/tmp/kfocus-rollback';
_snapshotMetaDb='/btrfs_main/kfocus-rollback-snapshot-metadb';
## . END Declare and assign global vars }

## BEGIN Run mainFn when script is NOT sourced {
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  _binName="$(  readlink -f "$0"       )" || exit 101;
  _binDir="$(   dirname  "${_binName}" )" || exit 101;
  _baseDir="$(  dirname  "${_binDir}"  )" || exit 101;
  _baseName="$( basename "${_binName}" )" || exit 101;

  # Import libs and assign more global vars
  _libTable=(
    "${_baseDir}/lib/common.2.source"
    "${_baseDir}/lib/rollback.2.source"
  );
  _loadLibTableFn "${_libTable[@]}" || exit 1;

  _assignList=(
    '_btrfsExe|/usr/bin/btrfs'
    '_btrfsBalanceExe|/usr/bin/btrfs-balance-least-used'
    '_btduExe|/usr/bin/btdu'
    '_diffExe|/usr/bin/diff'
    "_filefragExe|${_binDir}/kfocus-report-filefrag"
    '_kwriteconfig5Exe|/usr/bin/kwriteconfig5'
    '_kreadconfig5Exe|/usr/bin/kreadconfig5'
  );

  if ! _cm2AssignExeVarsFn "${_assignList[@]}"; then
    _cm2ErrStrFn 'Could not assign variables';
    exit 1;
  fi

  _cm2SetLogTagFn 'kfocus-rollback-backend';

  # Set error messages
  _browStr='<tr><td style="padding:8px 32px 8px 0">';
  _erowStr='</td></tr>';
  _tableStr='<table style="width:100%;margin-right:32px">';

  _prepareFailMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">Critical Error</h3>${_erowStr}

${_browStr}FocusRx was interrupted while attempting to set up system<br>
file snapshotting. This incident may be the result of failing<br>
hardware or a software conflict.${_erowStr}

${_browStr}<b>Please report this issue to technical support. This is not<br>
normal and should never happen.</b>${_erowStr}</table>
${_cm2HtmEndStr}
EOF
  )";

  _lowDiskMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">System Rollback: Low Disk Space</h3>
${_erowStr}

${_browStr}System Rollback has detected that the system's disk space is<br>
low. This could result in filesystem corruption if not corrected.<br>
Snapshot maintenance has been paused until this is corrected.<br>
<br>
It is highly recommended that you delete large snapshots<br>
using System Rollback. You may also need to delete excess files<br>
or move them to other drives.<br>
<br>
You can access System Rollback by clicking <code>Start Menu &gt;<br>
Kubuntu Focus Tools &gt; System Rollback</code>. Click "Show<br>
Snapshot Sizes" when prompted to quickly find large snapshots.<br>
${_cm2HtmEndStr}
EOF
  )";

  _lowBootMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">System Rollback: Low Boot Space</h3>
${_erowStr}

${_browStr}System Rollback has detected that the system's boot<br>
filesystem is low on space. This could result in failure to<br>
boot. Snapshot maintenance has been paused until this<br>
is corrected.<br>
<br>
It is highly recommended that you run the Kernel Cleaner<br>
utility. You can access the Kernel Cleaner by clicking <code>Start<br>
Menu &gt; Kubuntu Focus Tools &gt; Kernel Cleaner</code>.
${_cm2HtmEndStr}
EOF
  )";

  _inconsistentMsg="$(cat <<EOF
${_cm2HtmBeginStr}${_tableStr}
${_browStr}<h3 style="color:#f7941d">Inconsistent FS Layout</h3>${_erowStr}

${_browStr}This computer's file system layout was changed from the<br>
default. This breaks system snapshots and rollback.${_erowStr}

${_browStr}If you moved <code>/btrfs_main</code> or <code>/btrfs_boot</code>,
please move<br>
them back to their original locations. If you did not move<br>
either of these directories, please contact technical support.
${_erowStr}</table>
${_cm2HtmEndStr}
EOF
  )";

  _mainFn "$@";
fi
## . END Run mainFn when script is NOT sourced }
