#!/bin/bash
#
# Copyright 2019-2024 MindShare Inc.
#
# Written for the Kubuntu Focus by M. Mikowski and A. Rainbolt
#
# Name     : kfocus-btrfs-optimize
# Summary  : kfocus-btrfs-optimize (maintain | deepClean)
# Purpose  : Performs maintenance and disk cleanup for KFocus systems using
#            BTRFS.
# Example  : kfocus-btrfs-optimize
# License  : GPLv2
# Run By   : kfocus-focusrx, kfocus-focusrx-system
# Spec     : 4201
#
set -u;

## BEGIN _loadLibTableFn {
# Summary : _loadLibTableFn <lib_str1> <lib_str2> ...
# Example : _loadLibTableFn "lib01:/usr/lib/lib01" "lib02";
# Purpose :
#   Import table of libs, one arg per lib.
#     * Each arg can have alternates delimited by colons ':'
#     * Fails if all alternates for a lib fails.
#     * Starting lib string '#:' means the following libs are optional.
#     * Diagnostics are sent to STDERR.
#     * Libs without a directory use ${_binDir} as the path
#
_loadLibTableFn () {
  declare _lib_table _lib_list _lib_line _raw_path _lib_file _is_loaded;
  _lib_table=("$@");

  ## Begin: Iterate over lib lines.
  for _lib_line in "${_lib_table[@]}"; do
    # Split line into alternates.
    #   Note: Echo removes trailing newline.
    readarray -d: -t _lib_list < <(echo -n "${_lib_line}");
    _is_loaded='n';

    ## Begin: Iterate over alternates.
    for _raw_path in "${_lib_list[@]}"; do
      [ -z "$(dirname "${_raw_path}")" ] \
        && _lib_file="${_binDir}/${_raw_path}" \
        || _lib_file="${_raw_path}";

      # shellcheck disable=SC1090
      if ! [ -r "${_lib_file}" ]; then
        _stderrFn "warn: source |${_lib_file}| not readable.";
      elif source "${_lib_file}"; then
        _is_loaded='y';
        break;
      else
        _stderrFn "${_baseName} Error: source |${_lib_file}| is non-zero.";
        return 1;
      fi
    done
    ## . End: Iterate over alternates.

    if [ "${_is_loaded}" != 'y' ]; then
      _stderrFn "${_baseName} error: no lib loaded";
      return 1;
    fi
  done
  ## . End: Iterate over lib lines.

  return;
}
## . END _loadLibTableFn }

## BEGIN Define error and exit handling {
#
_trapExitFn () {
  1>&2 echo "${_baseName} was interrupted";
  rm "${_lockFile}" || true;
}

_chkSetFlockFn () {
  exec 211>"${_lockFile}" || exit 21;
  if ! flock -n -e 211; then
    _exitLOCK "Cannot get lock on ${_lockFile}";
  fi
  # Trap unexpected exits to clean up lock file
  trap _trapExitFn EXIT;
}

_exitCleanFn () {
  declare _int;
  _int="$(_cm2EchoIntFn "${1:-0}")";
  trap '' EXIT;
  rm "${_lockFile}" || true;
  exit "${_int}";
}

_exitWithCodeFn () {
  declare _int _msg;

  _int="$(_cm2EchoIntFn "${1:-0}")";
  _msg="${2:-}";

  if [ -n "${_msg}" ]; then
    1>&2 echo "${_msg}";
  fi
  _exitCleanFn "${_int}";
}

_exitNOTICE () { _exitWithCodeFn  0 "$@"; }
_exitERR ()    { _exitWithCodeFn  1 "$@"; }
_exitCRIT ()   { _exitWithCodeFn  2 "$@"; }
_exitALERT ()  { _exitWithCodeFn  3 "$@"; }
_exitEMERG ()  { _exitWithCodeFn  4 "$@"; }
_exitLOCK ()   { _exitWithCodeFn 20 "$@"; }
## . END Define error and exit handling }

## BEGIN _checkRootFn {
#
_checkRootFn () {
  if [ "$UID" = '0' ]; then
    return 0;
  else
    _cm2WarnStrFn 'This action requires root privileges.';
    return 1;
  fi
}
## . END _checkRootFn }

## BEGIN _getMainUsageReportFn {
#
_getMainUsageReportFn () {
  LC_ALL='C' "${_btrfsExe}" filesystem usage -b '/btrfs_main';
}
## . END _getMainUsageReportFn }

## BEGIN _getBootUsageReportFn {
#
_getBootUsageReportFn () {
  LC_ALL='C' "${_btrfsExe}" filesystem usage -b '/btrfs_boot';
}
## . END _getBootUsageReportFn }

## BEGIN _getMainBtduReportFn {
#
_getMainBtduReportFn () {
  LC_ALL='C' "${_btduExe}" --du --min-resolution=1M --headless '/btrfs_main'
}
## . END _getMainBtduReportFn }

## BEGIN _getMainFragReportFn {
#
_getMainFragReportFn () {
  "${_filefragExe}" '/btrfs_main/@';
}
## . END _getMainFragReportFn }

## BEGIN _balanceMainFn {
#
_balanceMainFn () {
  "${_btrfsBalanceExe}" -u 85 '/btrfs_main';
}
## . END _balanceMainFn }

## BEGIN _balanceBootFn {
#
_balanceBootFn () {
  "${_btrfsBalanceExe}" -u 85 '/btrfs_boot';
}
## . END _balanceBootFn }

## BEGIN _spaceReclaimFn {
#
_spaceReclaimFn () {
  declare _big_threshold _deep_clean_yn _btdu_report _report_val_list \
    _report_file_list _clean_file_list _report_idx _current_file _file_size;

  _big_threshold=10737418240; # 10 GiB
  _deep_clean_yn="${1:-n}";

  _btdu_report="$(
    _getMainBtduReportFn \
      | grep '<UNREACHABLE>' \
      | sort -nr \
      | sed 's|/<SINGLE>/<DATA>/<UNREACHABLE>||; /<ERROR>/d'
  )";

  readarray -t _report_val_list  < <(cut -f1 <<< "${_btdu_report}");
  readarray -t _report_file_list < <(cut -f2 <<< "${_btdu_report}");

  _clean_file_list=();
  for (( _report_idx=0; _report_idx < ${#_report_val_list[@]}; \
    _report_idx++ )); do
    _current_file="${_report_file_list[_report_idx]}"

    if [ -f "${_current_file}" ]; then
      _file_size="$(du -b "${_current_file}" | cut -f1)";
      _unreachable_size="${_report_val_list[_report_idx]}";
      
      if [ "${_deep_clean_yn}" = 'y' ]; then
        if [ "$(bc -l <<< "scale=2; \
           (${_unreachable_size} / ${_file_size}) > 0.05")" \
           = '1' ]; then
          _clean_file_list+=( "${_current_file}" );
        fi
      else
        if (( _file_size < _big_threshold )); then
          if [ "$(bc -l <<< "scale=2; \
             (${_unreachable_size} / ${_file_size}) > 0.15")" \
             = '1' ]; then
            _clean_file_list+=( "${_current_file}" );
          fi
        else
          if [ "$(bc -l <<< "scale=2; \
             (${_unreachable_size} / ${_file_size}) > 0.30")" \
             = '1' ]; then
            _clean_file_list+=( "${_current_file}" );
          fi
        fi
      fi
    fi
  done

  if [ "${_deep_clean_yn}" = 'y' ]; then
    if (( ${#_clean_file_list[@]} > 50 )); then
      _clean_file_list=( "${_clean_file_list[@]:0:50}" );
    fi
  else
    if (( ${#_clean_file_list[@]} > 10 )); then
      _clean_file_list=( "${_clean_file_list[@]:0:10}" );
    fi
  fi

  "${_reclaimExe}" "${_clean_file_list[@]}";
}
## . END _spaceReclaimFn }

## BEGIN _defragmentFn {
#
_defragmentFn () {
  declare _frag_report _frag_count_list _target_frag_list _file_list \
    _defrag_file_list _report_idx;

  _frag_report="$(
    _getMainFragReportFn \
    | sort -nr;
  )";
  
  readarray -t _frag_count_list  < <(cut -d'|' -f2 <<< "${_frag_report}");
  readarray -t _target_frag_list < <(cut -d'|' -f3 <<< "${_frag_report}");
  readarray -t _file_list        < <(cut -d'|' -f4 <<< "${_frag_report}");

  _defrag_file_list=();
  for (( _report_idx=0; _report_idx < ${#_file_list[@]}; \
    _report_idx++ )); do
    _current_file="${_file_list[_report_idx]}";

    if [ -f "${_current_file}" ]; then
      if (( _frag_count_list[_report_idx] > \
        _target_frag_list[_report_idx] )); then
        _defrag_file_list+=( "${_current_file}" );
      fi
    fi
  done

  if (( ${#_defrag_file_list[@]} > 50 )); then
    _defrag_file_list=( "${_defrag_file_list[@]:0:50}" );
  fi

  if [ "${#_defrag_file_list[@]}" -gt 0 ]; then
    "${_btrfsExe}" filesystem defragment "${_defrag_file_list[@]}";
  fi
}
## . END _defragmentFn }

## BEGIN _deleteAllSnapshotsFn {
# NOTICE: You must run kfocus-btrfs-optimize AS ROOT for this function to
# succeed. For security purposes, this is intentionally NOT part of
# kfocus-btrfs-optimize-set.
#
_deleteAllSnapshotsFn () {
  declare _snapshot_list _current_snapshot;

  readarray -t _snapshot_list < <(
    _cm2LsFn '/btrfs_main/@kfocus-rollback-snapshots' 2>/dev/null
  );

  if [ "${#_snapshot_list[@]}" = '0' ] || [ -z "${_snapshot_list[0]}" ]; then
    _cm2WarnStrFn 'No snapshots found.';
    return 1;
  fi

  for _current_snapshot in "${_snapshot_list[@]}"; do
    "${_snapshotSetExe}" deleteSnapshot "${_current_snapshot}";
  done
}

## BEGIN _mainFn {
#
_mainFn () {
  declare _mode;

  _chkSetFlockFn;

  _mode="${1:-}";
  case "${_mode}" in
    'maintain')
      _checkRootFn   || exit;
      _balanceMainFn || exit;
      _balanceBootFn || exit;
      _spaceReclaimFn;
      ;;
    'deepClean')
      _checkRootFn       || exit;
      _balanceMainFn 'y' || exit;
      _balanceBootFn     || exit;
      _spaceReclaimFn 'y';
      _deleteAllSnapshotsFn;
      _defragmentFn;
      ;;
    *) _cm2WarnStrFn  'Invalid mode specified.';;

  esac
  _exitCleanFn;
}
## . END _mainFn }

## BEGIN Declare and assign global vars {
declare _userId _binName _binDir _baseName _baseDir _lockFile;
## . END Declare and assign global vars }

## BEGIN Run mainFn when script is NOT sourced {
#
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  _binName="$(  readlink -f "$0"       )" || exit 101;
  _binDir="$(   dirname  "${_binName}" )" || exit 101;
  _baseDir="$(  dirname  "${_binDir}"  )" || exit 101;
  _baseName="$( basename "${_binName}" )" || exit 101;
  _lockFile='/tmp/kfocus-btrfs-optimize.lock';

  # Import libs and assign more global vars
  _libTable=(
    '/usr/lib/kfocus/lib/common.2.source'
    '/usr/lib/kfocus/lib/rollback.2.source'
  );

  _loadLibTableFn "${_libTable[@]}" || exit 1;

  _assignList=(
    '_btrfsExe|/usr/bin/btrfs'
    '_btrfsBalanceExe|/usr/bin/btrfs-balance-least-used'
    '_btduExe|/usr/bin/btdu'
    "_snapshotSetExe|${_binDir}/kfocus-rollback-set"
    "_reclaimExe|${_binDir}/kfocus-btrfs-reclaim-space"
    "_filefragExe|${_binDir}/kfocus-report-filefrag"
  );

  if ! _cm2AssignExeVarsFn "${_assignList[@]}"; then
    _cm2ErrStrFn 'Could not assign variable';
    exit 1;
  fi

  _mainFn "$@";
fi
## . END Run mainFn when script is NOT sourced }
