#!/bin/bash
#
# Copyright 2019-2024 MindShare Inc.
#
# Written for the Kubuntu Focus by M. Mikowski and A. Rainbolt
#
# Name     : kfocus-rollback-set
# Summary  : kfocus-rollback-set
# Purpose  : Does the actual snapshot create and restore operations
# Example  : kfocus-rollback-set restoreSnapshot @2024-01-01:01:23:45
# License  : GPLv2
# Run By   : Developers only
# Spec     : 4013
# Note     : WORK IN PROGRESS, DO NOT USE IN PRODUCTION
#
set -u;

# TODO: The kernel rollback mechanism does NOT check to see if the kernel it
#   sets as the target actually exists! It should check to see if the kernel
#   exists, and choose a "close" kernel if not (one of the same flavor which
#   is one version newer than the desired kernel). If that doesn't exist, it
#   should pick a one-version-newer generic kernel, if that doesn't exist it
#   should pick a one-version-newer lowlatency kernel, and if *that* doesn't
#   exist (insert screaming emoji) then it should just go with the newest
#   kernel available. If there isn't a kernel at all, it should yell very
#   loudly and not attempt the rollback at all.

## BEGIN _importCommonFn {
# Summary   : _importCommonFn
# Purpose   : Load common routines, prefer relative dir
# Example   : _importCommonFn;
# Arguments : none
# Globals   : Package vars _baseDir _baseName
# Outputs   : none
# Returns   : none
#
_importCommonFn () {
  declare _lib_list _is_loaded _lib_file;
  _lib_list=(
    "${_binDir}/common.2.source"
    '/usr/lib/kfocus/lib/common.2.source'
  );
  _is_loaded='n';
  for _lib_file in "${_lib_list[@]}"; do
    if [ -r "${_lib_file}" ]; then
      # shellcheck source=/usr/lib/kfocus/lib/common.2.source
      if source "${_lib_file}"; then
        _is_loaded='y';
        break;
      fi
    fi
  done

  if [ "${_is_loaded}" = 'n' ]; then
    echo 1>&2 "${_baseName}: ABORT - Cannot source common lib";
    exit 202;
  fi
}
## . END _importCommonFn }

_createSnapshotFn () {
  declare _kernel_str _timestamp_str _snapshot_path;

  _kernel_str="$(uname -r)";
  _timestamp_str="$(date +%s)";
  _snapshot_path="/btrfs_root/@kfocus-rollback-snapshots/@${_timestamp_str}";

  if [ -e "${_snapshot_path}" ]; then
    # This should theoretically never happen, but there's a non-zero chance
    # that it could if the user changes their clock backwards.
    #
    # TODO: There's a time-of-check to time-of-use bug here, I don't *think*
    # we care but review and see if this is important enough to find a way
    # around.
    exit 1;
  fi

  echo "${_kernel_str}" > /var/lib/kfocus/kfocus_rollback_kernel_id;
  btrfs subvolume snapshot -r '/btrfs_root/@' "${_snapshot_path}";
}

_restoreSnapshotFn () {
  declare _target_snapshot _snapshot_path _kernel_str;

  _target_snapshot="${1:-}";
  _snapshot_path="/btrfs_root/@kfocus-rollback-snapshots/${_target_snapshot}";

  if ! [ -e "${_snapshot_path}" ]; then
    exit 1;
  fi

  _kernel_str="$(cat ${_snapshot_path}/var/lib/kfocus/kfocus_rollback_kernel_id)";
  echo "GRUB_DEFAULT=\"Advanced options for Ubuntu>Ubuntu, with Linux ${_kernel_str}\"" \
    > /etc/default/grub.d/00_kfocus-rollback.cfg;
  update-grub;

  mv '/btrfs_root/@' '/btrfs_root/@kfocus-rollback-working' || exit 1;
  btrfs subvolume snapshot "${_snapshot_path}" '/btrfs_root/@'
}

_deleteSnapshotFn () {
  declare _target_snapshot _snapshot_path;

  _target_snapshot="${1:-}";
  # This intentionally does not have the @ before ${_target_snapshot} because
  # the function is passed a snapshot name, not just a timestamp.
  _snapshot_path="/btrfs_root/@kfocus-rollback-snapshots/${_target_snapshot}";

  if ! [ -e "${_snapshot_path}" ]; then
    exit 1;
  fi

  btrfs subvolume delete "${_snapshot_path}";
}

_restoreSnapshotStage2Fn () {
  if [ -z "$(mount | grep 'btrfs' | grep '@kfocus-rollback-working')" ]; then
    btrfs subvolume delete '/btrfs_root/@kfocus-rollback-working';
  fi
}

## BEGIN _mainFn {
#
_mainFn () {
  declare _mode _target_snapshot;

  _mode="${1:-}";

  case "${_mode}" in
    'createSnapshot')
      _createSnapshotFn;
      ;;
    'restoreSnapshot')
      _target_snapshot="${2:-}";
      if [ -z "${_target_snapshot}" ]; then
        _cm2WarnStrFn 'No snapshot name provided to restore!';
        exit 1;
      fi
      _restoreSnapshotFn "${_target_snapshot}";
      ;;
    'deleteSnapshot')
      _target_snapshot="${2:-}";
      if [ -z "${_target_snapshot}" ]; then
        _cm2WarnStrFn 'No snapshot name provided to delete!';
        exit 1;
      fi
      _deleteSnapshotFn "${_target_snapshot}";
      ;;
    'restoreSnapshotStage2')
      _restoreSnapshotStage2Fn;
      ;;
    *)
      # This should never happen
      exit 1;
      ;;
  esac
}
## . END _mainFn }

## BEGIN Declare and assign global vars {
declare _binName _binDir _baseName _baseDir;
## . END Declare and assign global vars }

## BEGIN Run mainFn when script is NOT sourced {
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  _binName="$(  readlink -f "$0"       )" || exit 101;
  _binDir="$(   dirname  "${_binName}" )" || exit 101;
  _baseDir="$(  dirname  "${_binDir}"  )" || exit 101;
  _baseName="$( basename "${_binName}" )" || exit 101;

  # Import libs and assign more global vars
  _importCommonFn;

  _mainFn "$@";
fi
## . END Run mainFn when script is NOT sourced }
